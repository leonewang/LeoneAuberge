<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Leone Auberge]]></title>
  <subtitle><![CDATA[God is in the detail]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://leonewang.wang/"/>
  <updated>2016-01-26T15:43:04.000Z</updated>
  <id>http://leonewang.wang/</id>
  
  <author>
    <name><![CDATA[Leone Wang]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Directive - Scope Binding Strategy in AngularJS]]></title>
    <link href="http://leonewang.wang/2016/01/26/directive-scope-binding-strategy-in-angularjs/"/>
    <id>http://leonewang.wang/2016/01/26/directive-scope-binding-strategy-in-angularjs/</id>
    <published>2016-01-26T15:43:04.000Z</published>
    <updated>2016-01-26T15:43:04.000Z</updated>
    <content type="html"><![CDATA[<p>我们经常想要我们的指令能够在特定的情况下与外界进行数据上的交互，所以在编写指令过程中经常会使用到独立 Scope 选项，这就需要借助绑定策略之手。</p>
<p>绑定策略的三种形式：<code>@</code>、 <code>=</code>、 <code>&amp;</code>。</p>
<h3 id="@"><a href="#@" class="headerlink" title="@"></a><code>@</code></h3><p>将本地作用域和 DOM 中的属性值（该属性值必须存在于父作用域中）进行绑定。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">directive(<span class="string">"direct"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> &#123;</span><br><span class="line">      restrict: <span class="string">'ECMA'</span>,</span><br><span class="line">      template: <span class="string">'&lt;div&gt;指令中：&#123;&#123; name &#125;&#125;&lt;/div&gt;'</span>,</span><br><span class="line">      scope:&#123;</span><br><span class="line">        name:<span class="string">'@forName'</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125; </span><br><span class="line">&#125;)</span><br><span class="line">.controller(<span class="string">"nameController"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">$scope</span>) </span>&#123;</span><br><span class="line">      $scope.Name=<span class="string">"leone"</span>; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>HTML</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">'nameController'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">direct</span> <span class="attribute">for-name</span>=<span class="value">'&#123;&#123;Name&#125;&#125;'</span>&gt;</span><span class="tag">&lt;/<span class="title">direct</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>运行结果就是上面指令 <code>scope:{name:&#39;@forName&#39;}</code> 中的 name 与父控制器中的 Name 属性绑定起来了，注意，<strong>属性名使用驼峰命名法</strong>。这里也可以简写为 <code>name：&#39;@&#39;</code>，如果这样写的话，就默认 DOM 中的属性名为 name，所以 DOM 中需要将属性修改为 <code>name=&#39;&#39;</code>。其实，另外两个绑定形式也有这样的简写规则。</p>
<h3 id="3D"><a href="#3D" class="headerlink" title="="></a><code>=</code></h3><p>= 与 @ 不同点在于，@ 主要是针对字符串使用，而 = 主要是针对某个对象的引用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">directive(<span class="string">"direct"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> &#123;</span><br><span class="line">      restrict: <span class="string">'ECMA'</span>,</span><br><span class="line">      template: <span class="string">'&lt;div&gt;指令中：&#123;&#123; case.name &#125;&#125;&lt;/div&gt;'</span>,</span><br><span class="line">      scope:&#123;</span><br><span class="line">        <span class="keyword">case</span>:<span class="string">'='</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.controller(<span class="string">"nameController"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">$scope</span>) </span>&#123;</span><br><span class="line">      $scope.data=[&#123;name:<span class="string">"leone"</span>&#125;,&#123;name:<span class="string">"wang"</span>&#125;]; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>HMTL</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"nameController"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">direct</span> <span class="attribute">case</span>=<span class="value">"data[0]"</span>&gt;</span><span class="tag">&lt;/<span class="title">direct</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">direct</span> <span class="attribute">case</span>=<span class="value">"data[1]"</span>&gt;</span><span class="tag">&lt;/<span class="title">direct</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>结果是一个 「leone」，一个「wang」。这个例子中，data 是一个对象数组，里面包含了两个对象，我们分别把这两个对象传递给了 DOM 中的 case 属性，case 属性就把这个对象的引用绑定给了指令 scope 中的 case，然后在模板中通过 <code></code> 进行使用。</p>
<h3 id="26amp_3B"><a href="#26amp_3B" class="headerlink" title="&amp;"></a><code>&amp;</code></h3><p>对父级作用域进行绑定，并将其中的属性值包装成一个函数，即任何类型的属性值都会被包装成一个函数，比如一个单纯的字符串，或是一个对象数组，或是一个函数方法，如果是字符串、对象数组和无参的函数，那么可想而知，它们都会被包装成一个无参的函数，若是有参的函数方法则反之，并且我们需要为其传入一个对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">myApp.directive(<span class="string">"direct"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">       restrict: <span class="string">'ECMA'</span>,</span><br><span class="line">       template: <span class="string">'&lt;div&gt;&lt;input ng-model="model"/&gt;&lt;/div&gt;'</span> + <span class="string">'&lt;div&gt;&lt;button ng-click="show(&#123;name:model&#125;)"&gt;show&lt;/button&gt;'</span>,</span><br><span class="line">       scope:&#123;</span><br><span class="line">           show:<span class="string">'&amp;'</span>              </span><br><span class="line">       &#125;                      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.controller(<span class="string">"nameController"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">$scope</span>)</span>&#123;</span><br><span class="line">    $scope.showName=<span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123; </span><br><span class="line">       alert(name); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>HTML</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"nameController"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">direct</span> <span class="attribute">show</span>=<span class="value">"showName(name)"</span>&gt;</span><span class="tag">&lt;/<span class="title">direct</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>将 DOM 中的 show 属性值 <code>showName(name)</code> 函数绑定到指令 scope 中的 show 上，然后通过模板中的点击事件触发 show 函数，并将一个叫做 model 的对象作为 name 参数传递了进去。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>我们经常想要我们的指令能够在特定的情况下与外界进行数据上的交互，所以在编写指令过程中经常会使用到独立 Scope 选项，这就需要借助绑定策略之手。</p>
<p>绑定策略的三种形式：<code>@</code>、 <code>=</code>、 <code>&amp;</code>。</p>
<h3 id="@"><a href="#@" class="headerlink" title="@"></a><code>@</code></h3><p>将本地作用域和 DOM 中的属性值（该属性值必须存在于父作用域中）进行绑定。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">directive(<span class="string">"direct"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> &#123;</span><br><span class="line">      restrict: <span class="string">'ECMA'</span>,</span><br><span class="line">      template: <span class="string">'&lt;div&gt;指令中：&#123;&#123; name &#125;&#125;&lt;/div&gt;'</span>,</span><br><span class="line">      scope:&#123;</span><br><span class="line">        name:<span class="string">'@forName'</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125; </span><br><span class="line">&#125;)</span><br><span class="line">.controller(<span class="string">"nameController"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">$scope</span>) </span>&#123;</span><br><span class="line">      $scope.Name=<span class="string">"leone"</span>; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="AngularJS" scheme="http://leonewang.wang/tags/angularjs/"/>
    
      <category term="JavaScript" scheme="http://leonewang.wang/tags/javascript/"/>
    
      <category term="directive" scheme="http://leonewang.wang/tags/directive/"/>
    
      <category term="Notes" scheme="http://leonewang.wang/categories/notes/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Difference Between Factory, Service and Provider in AngularJS]]></title>
    <link href="http://leonewang.wang/2016/01/20/angularjs-api-factory-service-provider/"/>
    <id>http://leonewang.wang/2016/01/20/angularjs-api-factory-service-provider/</id>
    <published>2016-01-20T15:10:05.000Z</published>
    <updated>2016-01-20T15:10:05.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u5DE5_u5382_u65B9_u5F0F__7C_Factory"><a href="#u5DE5_u5382_u65B9_u5F0F__7C_Factory" class="headerlink" title="工厂方式 | Factory"></a>工厂方式 | Factory</h2><p>如果有一个类或对象，需要首先为他提供一些参数和逻辑，然后才能对它进行初始化，那么就能够使用这里的 Factory 接口。Factory 是一个函数，它负责创建一些特定的值或者对象，下面是一个 Greeter 实例，这个函数需要一条问候语来初始化：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Greeter</span>(<span class="params">saluation</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.greet = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> saluation + name;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>greeter 函数实例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myapp.factory(<span class="string">'greeter'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">sal</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Greeter(sal);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>然后这样调用它：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> greeter = greeter(<span class="string">'Hello'</span>);</span><br></pre></td></tr></table></figure>
<h2 id="u670D_u52A1_u65B9_u5F0F__7C_Service"><a href="#u670D_u52A1_u65B9_u5F0F__7C_Service" class="headerlink" title="服务方式 | Service"></a>服务方式 | Service</h2><p>想要用 service 实现上面的实例，可以把 greet Factory 改为下面的 greet Service:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myApp.service(<span class="string">'greeter'</span>, Greeter);</span><br></pre></td></tr></table></figure>
<p>Service 与 Factory 的不同点在于，Factory 会直接调用传递给它的函数（ <code>function(sal) { ... }</code> ）后返回执行的结果；而 Service 将会通过调用传递给它的构造方法去执行 <strong>new</strong> 操作（ 示例中相当于返回了 <code>new Greeter</code> )，然后再返回结果。</p>
<h2 id="u4F9B_u5E94_u8005_u65B9_u5F0F__7C_Provider"><a href="#u4F9B_u5E94_u8005_u65B9_u5F0F__7C_Provider" class="headerlink" title="供应者方式 | Provider"></a>供应者方式 | Provider</h2><blockquote>
<p>Provider recipe is syntactically defined as a custom type that implements a <code>$get</code> method. This method is a factory function just like the one we use in Factory recipe. In fact, if you define a Factory recipe, an empty Provider type with the $get method set to your factory function is automatically created under the hood.</p>
</blockquote>
<p>Provider recipe 是语法定义为一个自定义类型，实现 <code>$get</code> 的方法。这个方法是一个工厂方法，就像我们在 Factory recipe 中使用的一样。事实上，如果定义一个 Factory recipe，钩子会自动创建一个包含空 Provider 类型 $get 方法的工厂方法。</p>
<blockquote>
<p>You should use the Provider recipe only when you want to expose an API for application-wide configuration that must be made before the application starts. This is usually interesting only for reusable services whose behavior might need to vary slightly between applications.</p>
</blockquote>
<p>只有当希望一个应用程序配置的 API 必须在应用程序启动之前被创建，才应该使用 Provider recipe 。通常只关注可重用服务的行为可能在应用程序间略有不同。</p>
<p>Provider 的使用最为复杂，但是也是可定制性最高的部分，Provider 中既绑定了 Factory 也绑定了 Service，并且在注入系统准备完毕之前，还可以使用模板的 API 创建一个含有注入 Provider 的 config 方法，下面使用 Provider 改造：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">myApp.provider(<span class="string">'greeter'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> saluation = <span class="string">'Hello'</span>;</span><br><span class="line">    <span class="keyword">this</span>.setSaluation = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">        saluation = s;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Greeter</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.greet = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> salustion + <span class="string">' '</span> + a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.$get = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>)  </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Greeter(a);  </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在 config 阶段，只有 Provider 能被注入：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myApp.config(<span class="function"><span class="keyword">function</span>(<span class="params">greeter</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//不会运行 -- greeter是一个服务的实例</span></span><br><span class="line">  <span class="comment">//只有服务的provider能被注入到config中</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>但是可以通过下面的方法注入，之后 Angular 就会调用这个 Provider 的 <code>$get</code> 函数来返回该服务的一个实例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myApp.config(<span class="function"><span class="keyword">function</span>(<span class="params">greeterProvider</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// It will work</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<div class="tip"><br>无论何时为服务定义了一个 Provider，这个 Provider 的名字都是 serviceProvider，service 是服务的名称。<br></div>

<h2 id="u603B_u7ED3__7C_Conclusion"><a href="#u603B_u7ED3__7C_Conclusion" class="headerlink" title="总结 | Conclusion"></a>总结 | Conclusion</h2><table>
<thead>
<tr>
<th style="text-align:left">Feature / Recipe type</th>
<th style="text-align:center">Factory</th>
<th style="text-align:center">Service</th>
<th style="text-align:center">Provider</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Can have dependencies - 支持依赖注入</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:left">Uses type friendly injection - 使用友好的方式注入</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
<td style="text-align:center">×</td>
</tr>
<tr>
<td style="text-align:left">Object available in config phase - 配置阶段可用</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:left">Can create functions / primitives - 可以创建方法、基元</td>
<td style="text-align:center">√</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u5DE5_u5382_u65B9_u5F0F__7C_Factory"><a href="#u5DE5_u5382_u65B9_u5F0F__7C_Factory" class="headerlink" title="工厂方式 | Factory"></a>工厂方式 | Factory</h2><p>如果有一个类或对象，需要首先为他提供一些参数和逻辑，然后才能对它进行初始化，那么就能够使用这里的 Factory 接口。Factory 是一个函数，它负责创建一些特定的值或者对象，下面是一个 Greeter 实例，这个函数需要一条问候语来初始化：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Greeter</span>(<span class="params">saluation</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.greet = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> saluation + name;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="AngularJS" scheme="http://leonewang.wang/tags/angularjs/"/>
    
      <category term="JavaScript" scheme="http://leonewang.wang/tags/javascript/"/>
    
      <category term="Notes" scheme="http://leonewang.wang/categories/notes/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[AngularJS Notes]]></title>
    <link href="http://leonewang.wang/2016/01/18/angularjs-notes/"/>
    <id>http://leonewang.wang/2016/01/18/angularjs-notes/</id>
    <published>2016-01-18T12:13:22.000Z</published>
    <updated>2016-01-18T12:13:22.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>REF:<br><a href="http://baike.baidu.com/link?url=SlAzoxj6IVBVqvcoKI6EExxuU1a4yXzW9CiSMFdN9azJXxovxoD0LCo9ZoMZ58KFC7M-jQkMfZ9GtJeXH2r0M_" target="_blank" rel="external">AngularJS 2013 Brad Green</a><br><a href="http://blog.csdn.net/renfufei/article/details/19038123" target="_blank" rel="external">http://blog.csdn.net/renfufei/article/details/19038123</a></p>
</blockquote>
<h2 id="u4F9D_u8D56_u6CE8_u89E3__7C_Dependency_Annotation"><a href="#u4F9D_u8D56_u6CE8_u89E3__7C_Dependency_Annotation" class="headerlink" title="依赖注解 | Dependency Annotation"></a>依赖注解 | Dependency Annotation</h2><p>injector 怎么知道需要注入何种 service 呢?<br>为了解决依赖关系,应用程序开发者需要提供 injector 需要的 annotation 信息。在 Angular 中,某些API函数通过使用 injector 来调用,请按照API文档。injector 需要知道注入哪些服务给函数。下面是通过 service name 信息对代码进行注解的三种等价方式。他们都是等价的，可以在适当的地方互换使用.<br><a id="more"></a></p>
<h3 id="u63A8_u65AD_u4F9D_u8D56_u5173_u7CFB__7C_Inferring_Dependencies"><a href="#u63A8_u65AD_u4F9D_u8D56_u5173_u7CFB__7C_Inferring_Dependencies" class="headerlink" title="推断依赖关系 | Inferring Dependencies"></a>推断依赖关系 | Inferring Dependencies</h3><p>最简单的获取依赖的方式,就是让函数参数名和依赖的名字一致。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyController</span>(<span class="params">$scope, greeter</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给定一个 function, injector 通过检查函数声明和提取参数名称可以推断出 service 的名称 。在上面的例子中, $scope 和 greeter 是需要注入 function 的两个 services。<br>虽然简单直接, 但这种方法在 JavaScript 压缩/混淆 时会失效,因为会重命名方法的参数名。这使得这种注解方式只适用于 <a href="http://www.pretotyping.org/" target="_blank" rel="external">pretotyping</a>, 或者 demo 程序中。</p>
<h3 id="24inject__u6CE8_u89E3__7C__24inject_Annotation"><a href="#24inject__u6CE8_u89E3__7C__24inject_Annotation" class="headerlink" title="$inject 注解 | $inject Annotation"></a>$inject 注解 | $inject Annotation</h3><p>在产品级的代码中往往会压缩代码，这会重命名方法参数名，AngularJS 便无法判断出原来所需要的服务和变量，为了能够在重命名方法参数名后依然可以注入正确的 services, 函数需要通过 $inject 属性来注解. $inject 属性是一个数组,包含 需要注入的 service 名字。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyController = <span class="function"><span class="keyword">function</span>(<span class="params">renamed$scope, renamedGreeter</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">MyController[<span class="string">'$inject'</span>] = [<span class="string">'$scope'</span>, <span class="string">'greeter'</span>];</span><br></pre></td></tr></table></figure>
<p>在这种情况下,$inject数组中的值的顺序必须和要注入的参数的顺序一致。使用上面的代码片段作为一个例子, <code>$scope</code> 将注入到 <code>renamed$scope</code>, 而 <code>greeter</code> 将注入到 <code>renamedGreeter</code>。再次提醒注意 $inject 注解必须和 函数声明时的实际参数保持同步(顺序,个数…)。<br>对于 controller 声明,这种注解方法是很有用的,因为它将注解信息赋给了 function。</p>
<h3 id="u5185_u8054_u6CE8_u89E3__7C_Inline_Annotation"><a href="#u5185_u8054_u6CE8_u89E3__7C_Inline_Annotation" class="headerlink" title="内联注解 | Inline Annotation"></a>内联注解 | Inline Annotation</h3><p>有时候并不方便使用 $inject 注解,比如在注解 directives的时候。比如下面的示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">someModule.factory(<span class="string">'greeter'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">$window</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>因为需要使用临时变量，导致代码膨胀为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> greeterFactory = <span class="function"><span class="keyword">function</span>(<span class="params">renamed$window</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line">greeterFactory.$inject = [<span class="string">'$window'</span>];</span><br><span class="line">someModule.factory(<span class="string">'greeter'</span>, greeterFactory);</span><br></pre></td></tr></table></figure>
<p>这也是提供第三种注解的原因，以数组形式注入：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">someModule.factory(<span class="string">'greeter'</span>, [<span class="string">'$window'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">renamed$window</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;]);</span><br></pre></td></tr></table></figure>
<p><strong>所有的 annotation 风格都是等价的,在 Angular 中,只有支持注入的地方都可以使用.</strong></p>
<h2 id="24http_Service_Configuration"><a href="#24http_Service_Configuration" class="headerlink" title="$http Service Configuration"></a>$http Service Configuration</h2><p>$http 配置请求模板：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$http(&#123;&#10;    method: string,&#10;    url: string,&#10;    params: object,&#10;    data: string or object,&#10;    headers: object,&#10;    transformRequest: function transform(data, headerGetter) or an array of functions,&#10;    transformResponse: function transform(data, headerGetter) or an array of functions,&#10;    cache: boolean or Cache object,&#10;    timeout: number,&#10;    withCredentials: boolean&#10;&#125;);</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>transformRequest</code> 如果请求的配置对象属性中包含 JS 对象，那么就把这个对象序列化成 JSON 格式。</li>
<li><code>transformResponse</code> 如果检测到了 XSRF(Cross-site Request Forgery) 前缀，则直接丢弃；如果检测到了 JSON 响应，则使用 JSON 解析器对其反序列化。</li>
</ul>
<p>假设有一个服务，需要 POST 数据使用 <code>key1=1&amp;key2=2</code> 来代替 JSON 格式的 <code>{key1: 1, key2: 2}</code>，于是在请求中进行这种转换：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Angular.module(<span class="string">'myApp'</span>)</span><br><span class="line">    .config(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        $httpProvider.defaults.transformRequest = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 使用 jQuery 的 param 方法</span></span><br><span class="line">            <span class="comment">// 把 JSON 数据转换成字符串形式</span></span><br><span class="line">            <span class="keyword">return</span> $.param(data);</span><br><span class="line">        &#125;   </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="u4F7F_u7528_RESTful__u8D44_u6E90"><a href="#u4F7F_u7528_RESTful__u8D44_u6E90" class="headerlink" title="使用 RESTful 资源"></a>使用 RESTful 资源</h2><h3 id="u58F0_u660E"><a href="#u58F0_u660E" class="headerlink" title="声明"></a>声明</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$resource(<span class="string">'/url/:id'</span>,&#123;id: <span class="string">'@userId'</span>&#125;);</span><br></pre></td></tr></table></figure>
<p><code>@userId</code> 表示如果正在使用一个从服务端返回的对象，当调用这个对象上的任一方法时，对象上的 <code>userId</code> 属性都会被赋给 <code>id</code> 参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CreditCard.get(&#123;id: <span class="number">123</span>&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">card</span>) </span>&#123;</span><br><span class="line">    card.userId = <span class="number">345</span>;</span><br><span class="line">    <span class="comment">// card 对象中的 userId 将赋给 id</span></span><br><span class="line">    card.$save();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="u81EA_u5B9A_u4E49_u65B9_u6CD5"><a href="#u81EA_u5B9A_u4E49_u65B9_u6CD5" class="headerlink" title="自定义方法"></a>自定义方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">myModule.factory(<span class="string">'CreditCard'</span>, [<span class="string">'$resource'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">$resource</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $resource(<span class="string">'/user/:id'</span>, </span><br><span class="line">        &#123;id: <span class="string">'@userId'</span>&#125;,</span><br><span class="line">        &#123;charge: &#123;</span><br><span class="line">            method: <span class="string">'POST'</span>, <span class="comment">// 请求类型</span></span><br><span class="line">            params: &#123;charge: <span class="literal">true</span>&#125;,  <span class="comment">// 传递的参数</span></span><br><span class="line">            isArray: <span class="literal">false</span> <span class="comment">// 返回的结果是否是一个数组</span></span><br><span class="line">        &#125;&#125;);</span><br><span class="line">&#125;]);</span><br></pre></td></tr></table></figure>
<p>这里指定了一个 <code>charge</code> 方法，可以通过一个对象作为 <code>$resource</code> 的第三个参数来配置这个方法，对象中的 key 就是需要暴露的方法名称。</p>
<blockquote>
<p>这是一种灵活的编码风格，根据上面的代码，对于配置对象 <code>{charge: {method: &#39;POST&#39;, params: {charge: true}, isArray: false}}</code>，Angular 会将其解析成一个方法，然后把这个方法绑定到返回的 RESTful 对象上。</p>
</blockquote>
<p>上面的配置对象解释之后的方法为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CreditCard.charge = <span class="function"><span class="keyword">function</span>(<span class="params">charge, isArray</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Callback"><a href="#Callback" class="headerlink" title="Callback"></a>Callback</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> card = CreditCard.query();</span><br></pre></td></tr></table></figure>
<p>上面的 <code>query</code> 调用并没有像 <code>get</code> 一样在回调函数中进行赋值，而是直接将信用卡对象赋值给了 card 变量，你可能会担心在对服务器进行异步请求的情况下，这种代码还能正常运行吗？</p>
<p>这种担心是合理的，但事实上，这段代码完全正确，并且能够运行。这里发生的事情是：Angular 赋给了 card 对象一个（所返回对象或者数组的）引用，只有在未来某个时间对服务器的请求返回来之后，这个引用才被真正的赋值。<strong>在此期间，引用对象一直是空的。</strong></p>
<h2 id="Directive"><a href="#Directive" class="headerlink" title="Directive"></a>Directive</h2><p>从高层面看 Angular 的初始化过程：</p>
<ol>
<li><p><strong>加载脚本</strong><br>加载 Angular 库，并查找 ng-app 指令，从而找到引用边界。</p>
</li>
<li><p><strong>编译阶段</strong><br>在这个阶段中，Angular 将会遍历 DOM 结构，标识出模板中注册的所有指令。对于每一条命令，它会根据指令定义的规则来转换 DOM 结构，如果存在 compile 函数，则调用它。调用 compile 函数将得到一个编译好的 template 函数，它将会调用从指令中搜集而来的 link 函数。</p>
</li>
<li><p><strong>链接阶段</strong><br>为了让视图称为动态的，Angular 会对每条指令运行一个 link 函数。link 函数的一般操作是在 DOM 或者模型上创建监听器，监听器会使视图和模型的内容随时保持同步。</p>
</li>
</ol>
<p>总结来说，后两个阶段就是负责转换模板的编译阶段，以及修改视图中数据的链接阶段。</p>
<h3 id="u6307_u4EE4_u5B9A_u4E49_u9009_u9879"><a href="#u6307_u4EE4_u5B9A_u4E49_u9009_u9879" class="headerlink" title="指令定义选项"></a>指令定义选项</h3><ul>
<li><code>compile</code> 对模板自身进行转换和编译，此函数在生命周期中只调用一次。如使用 ng-repeat 时，会以编程的方式修改 DOM 模板，生成多个 DOM 元素实例。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">compile: <span class="function"><span class="keyword">function</span> <span class="title">compile</span>(<span class="params">tElement, tAttrs, transclude</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  &#123;</span><br><span class="line">        pre: <span class="function"><span class="keyword">function</span> <span class="title">preLink</span>(<span class="params">scope, iElement, iAttrs, controller</span>) </span>&#123;...&#125;, <span class="comment">// 运行于编译阶段之后，指令链接到子元素之前</span></span><br><span class="line">        post: <span class="function"><span class="keyword">function</span> <span class="title">postLink</span>(<span class="params">scope, iElement, iAttrs, controller</span>) </span>&#123;...&#125;, <span class="comment">// 运行于所有子元素指令都链接之后</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>link</code> 负责在模型和视图之间进行动态关联。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">preLink</span>(<span class="params">scope, iElement, iAttrs, controller</span>) </span>&#123;...&#125;,</span><br></pre></td></tr></table></figure>
<p>作用域在链接阶段才会被绑定到编译之后的 link 函数上，然后再通过数据绑定技术，指令就变成了动态的。如果要修改 DOM 结构必须在 <code>postLink</code> 函数中来执行，如果在 <code>preLink</code> 中执行，则会破坏数据绑定过程，导致链接出错。</p>
<div class="tip"><br><div><strong>compile 函数和 link 函数不同点</strong></div><br><div>1. link 函数会访问 scope 对象，而 compile 不会。这是因为，scope 对象在编译阶段还不存在。</div><br><div>2. compile 函数会接收模板元素及其属性列表，而 link 函数会接收到视图实例对象（视图实例由模板创建）。</div><br></div>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>REF:<br><a href="http://baike.baidu.com/link?url=SlAzoxj6IVBVqvcoKI6EExxuU1a4yXzW9CiSMFdN9azJXxovxoD0LCo9ZoMZ58KFC7M-jQkMfZ9GtJeXH2r0M_">AngularJS 2013 Brad Green</a><br><a href="http://blog.csdn.net/renfufei/article/details/19038123">http://blog.csdn.net/renfufei/article/details/19038123</a></p>
</blockquote>
<h2 id="u4F9D_u8D56_u6CE8_u89E3__7C_Dependency_Annotation"><a href="#u4F9D_u8D56_u6CE8_u89E3__7C_Dependency_Annotation" class="headerlink" title="依赖注解 | Dependency Annotation"></a>依赖注解 | Dependency Annotation</h2><p>injector 怎么知道需要注入何种 service 呢?<br>为了解决依赖关系,应用程序开发者需要提供 injector 需要的 annotation 信息。在 Angular 中,某些API函数通过使用 injector 来调用,请按照API文档。injector 需要知道注入哪些服务给函数。下面是通过 service name 信息对代码进行注解的三种等价方式。他们都是等价的，可以在适当的地方互换使用.<br>]]>
    
    </summary>
    
      <category term="AngularJS" scheme="http://leonewang.wang/tags/angularjs/"/>
    
      <category term="JavaScript" scheme="http://leonewang.wang/tags/javascript/"/>
    
      <category term="Notes" scheme="http://leonewang.wang/categories/notes/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[GitHub/GitCafe Domain Binding Principle]]></title>
    <link href="http://leonewang.wang/2016/01/01/github-gitcafe-domain-binding-principle/"/>
    <id>http://leonewang.wang/2016/01/01/github-gitcafe-domain-binding-principle/</id>
    <published>2016-01-01T09:21:02.000Z</published>
    <updated>2016-01-01T09:21:02.000Z</updated>
    <content type="html"><![CDATA[<p>根据<a href="https://www.zhihu.com/question/26609475" target="_blank" rel="external">Rainux Luo, CTO@GitCafe</a>在知乎的描述和自己的理解做出描述：</p>
<ol>
<li>GitHub/GitCafe 会为每个包含 gh-pages/gitcafe-pages 分支的项目创建包含该分支内容的、符合特定命名规则的目录 wwwroot。</li>
<li>GitHub/GitCafe 虚拟了一个服务器，它被配置成使用 Name-based Virtual Server  方式来发布该分支下的目录内容，这个被虚拟服务器的域名就是 <code>{username}.gitxxx.io</code> 或者是用户绑定的域名，那么自然可以访问静态页面。</li>
<li><p>那么域名是如何绑定到这个虚拟服务器上的呢？首先要知道 <code>A</code> 和 <code>CNAME</code> 记录的概念。</p>
<a id="more"></a>
<ul>
<li><code>A</code> 主要用来指定主机或者域名对应的 IP 地址，告诉 DNS 网站所在服务器的地址，这样用户输入域名后 DNS 才能找到网站。</li>
<li><code>CNAME</code> 别名记录，这种记录允许您将多个名字映射到同一台计算机。</li>
</ul>
<div class="tip">我们的服务器的地址可能会随时发生变动，并不是固定不变的，这时候就要用到 CNAME 记录，它会指定一个 DNS 服务商提供的二级域名，这样 DNS 通过这个二级域名也能找到服务器的 IP 地址。使用CNAME的好处是，即使服务器的IP地址发生变更，也不用更改解析记录，DNS会自动更新解析，相比A记录少了一些改动的麻烦。</div>
</li>
<li><p>Pages 用户将要绑定的域名 A 记录或 CNAME 记录指向该虚拟服务器所在主机，所有人就可以像访问普通静态网站一样访问 Pages 站点。</p>
</li>
<li>当我们绑定了域名后，<code>{username}.gitxxx.io</code> 就和我们绑定的域名一样能够访问到项目分支所在的虚拟主机，由于 <code>{username}.gitxxx.io</code> 是 GitHub/GitCafe 下的子域名，为了告诉访问者我们的域名是哪个，因此要在项目分支下添加一个 CNAME 文件。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>根据<a href="https://www.zhihu.com/question/26609475">Rainux Luo, CTO@GitCafe</a>在知乎的描述和自己的理解做出描述：</p>
<ol>
<li>GitHub/GitCafe 会为每个包含 gh-pages/gitcafe-pages 分支的项目创建包含该分支内容的、符合特定命名规则的目录 wwwroot。</li>
<li>GitHub/GitCafe 虚拟了一个服务器，它被配置成使用 Name-based Virtual Server  方式来发布该分支下的目录内容，这个被虚拟服务器的域名就是 <code>{username}.gitxxx.io</code> 或者是用户绑定的域名，那么自然可以访问静态页面。</li>
<li><p>那么域名是如何绑定到这个虚拟服务器上的呢？首先要知道 <code>A</code> 和 <code>CNAME</code> 记录的概念。</p>]]>
    
    </summary>
    
      <category term="Domain" scheme="http://leonewang.wang/tags/domain/"/>
    
      <category term="Git" scheme="http://leonewang.wang/tags/git/"/>
    
      <category term="Summarize" scheme="http://leonewang.wang/categories/summarize/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[AngularJS Resource Interface With RESTful API]]></title>
    <link href="http://leonewang.wang/2015/12/22/angularjs-resource-interface-with-restful-api/"/>
    <id>http://leonewang.wang/2015/12/22/angularjs-resource-interface-with-restful-api/</id>
    <published>2015-12-21T17:23:15.000Z</published>
    <updated>2015-12-21T17:23:15.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>REF:<br><a href="https://docs.angularjs.org/api/ngResource/service/$resource" target="_blank" rel="external">AngularJS Document</a><br><a href="http://harttle.com/2015/06/05/angular-resource.html" target="_blank" rel="external">http://harttle.com/2015/06/05/angular-resource.html</a></p>
</blockquote>
<p><a href="https://zh.wikipedia.org/zh-cn/REST" target="_blank" rel="external">REST</a>（表征性状态传输，Representational State Transfer）是Roy Fielding博士在2000年他的博士论文中提出来的一种软件架构风格。RESTful风格的设计不仅具有更好的可读性（Human Readable），而且易于做缓存以及服务器扩展（scalability）。REST风格体现在URL设计上：</p>
<ul>
<li>每个URL对应一个资源</li>
<li>对资源的不同操作对应于HTTP的不同方法</li>
<li>资源表现形式（representation）通过<code>Accept</code>和<code>Content-Type</code>指定<br>AngularJS提供了$resourceService来更方便地与RESTful服务器API进行交互，可以方便地定义一个REST资源，而不必手动所有的声明CRUD方法。<a id="more"></a>
<h2 id="Resource_Factory"><a href="#Resource_Factory" class="headerlink" title="Resource Factory"></a>Resource Factory</h2></li>
</ul>
<p><code>$resourceService</code>定义在<code>ngResourceModule</code>中，需要在你的HTML中引入这个Module对应的JS，同时在你的APP中添加这样一个依赖：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = angular.module(<span class="string">'helloApp'</span>, [<span class="string">'ngResource'</span>]);</span><br></pre></td></tr></table></figure>
<p>然后为资源建立一个Factory：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.factory(<span class="string">'Notes'</span>, [<span class="string">'$resource'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">$resource</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $resource(<span class="string">'/notes/:id'</span>);</span><br><span class="line">&#125;]);</span><br></pre></td></tr></table></figure>
<p>当然，你也可以不把<code>$resource的</code>实例放到Factory里，直接在控制器中存起来：<code>var Notes = $resource(&#39;/notes/:id&#39;)</code>。</p>
<p>CRUD</p>
<p>在你的控制器中就可以对资源进行增删改查了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">app.controller(<span class="string">'NotesCtrl'</span>, [<span class="string">'$scope'</span>, <span class="string">'Notes'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">$scope, Notes</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> notes = Notes.query(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// GET: /notes</span></span><br><span class="line">        <span class="comment">// Response: [&#123;id: 1, content: 'hello'&#125;, &#123;id: 2, content: 'world'&#125;];</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> first = notes[<span class="number">0</span>];</span><br><span class="line">        first.content = <span class="string">'halo'</span>;</span><br><span class="line">        first.$save();</span><br><span class="line">        <span class="comment">// POST: /notes/1 &#123;id: 1, content: 'halo'&#125;</span></span><br><span class="line">        <span class="comment">// Response: &#123;id: 1, content: 'halo'&#125;</span></span><br><span class="line"></span><br><span class="line">        second.$<span class="keyword">delete</span>();</span><br><span class="line">        <span class="comment">// DELETE: /notes/2</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> note = <span class="keyword">new</span> Notes(&#123;content: <span class="string">'xxx'</span>&#125;);</span><br><span class="line">    note.$save();</span><br><span class="line">    <span class="comment">// POST: /notes</span></span><br><span class="line">    <span class="comment">// Response: &#123;id: 3, content: 'xxx'&#125;</span></span><br><span class="line">&#125;]);</span><br></pre></td></tr></table></figure>
<h2 id="PUT__u64CD_u4F5C"><a href="#PUT__u64CD_u4F5C" class="headerlink" title="PUT 操作"></a>PUT 操作</h2><p><code>$resource</code>提供了五种默认操作：<code>get</code>, <code>query</code>, <code>save</code>, <code>remove</code>, <code>delete</code>。你可以配置一个update操作来完成HTTP PUT：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.factory(<span class="string">'Notes'</span>, [<span class="string">'$resource'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">$resource</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $resource(<span class="string">'/notes/:id'</span>, <span class="literal">null</span>, &#123;</span><br><span class="line">        update: &#123; method:<span class="string">'PUT'</span> &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;]);</span><br></pre></td></tr></table></figure>
<p>现在，你可以在控制器中获取一个note并更新它：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> note = Notes.get(&#123; id: <span class="number">3</span>&#125;),</span><br><span class="line">    $id = note.id;</span><br><span class="line"></span><br><span class="line">note.content = <span class="string">'yyy'</span>;</span><br><span class="line">Notes.update(&#123; id:$id &#125;, note);</span><br><span class="line"><span class="comment">// PUT /notes/3 &#123;id: 3, content: 'yyy'&#125;</span></span><br></pre></td></tr></table></figure>
<p>现在你的Notes有六种操作了。这些操作有两种调用方式：</p>
<ul>
<li>通过资源类调用，例如：<code>Notes.update({id: xxx})；</code></li>
<li>通过资源实例调用，例如：<code>note.$update()</code>，此时操作名需加前缀$。<br>具体的调用参数可参考文档：</li>
</ul>
<blockquote>
<p>HTTP GET “class” actions: Resource.action([parameters], [success], [error])<br>non-GET “class” actions: Resource.action([parameters], postData, [success], [error])<br>non-GET instance actions: instance.$action([parameters], [success], [error])</p>
</blockquote>
<p>其中，success参数为<code>(value, responseHeaders)</code>，error参数为<code>(httpResponse)</code>。</p>
<h2 id="u5C5E_u6027/URL_u6620_u5C04"><a href="#u5C5E_u6027/URL_u6620_u5C04" class="headerlink" title="属性/URL映射"></a>属性/URL映射</h2><p>上述例子中，我们看到note对象的id属性会映射到URL中的<code>:id</code>（<code>/notes/:id</code>）。如果你的业务更加复杂，可以手动配置这个映射关系。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Notes = $resouce(<span class="string">'/users/:userId/notes/:noteId'</span>, &#123;</span><br><span class="line">    noteId: <span class="string">'@id'</span>,</span><br><span class="line">    userId: <span class="string">'@owner'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将会 <strong>读取note的owner和id属性</strong> 来生成URL，比如删除note时：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// note === &#123;id: 123, owner: 'alice', content: 'hello'&#125;</span></span><br><span class="line">note.$<span class="keyword">delete</span>();</span><br><span class="line"><span class="comment">// DELETE: /users/alice/notes/123</span></span><br></pre></td></tr></table></figure>
<p><strong>在构造<code>$resource</code>时，多于的属性映射会成为URL Query</strong>。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Notes = $resouce(<span class="string">'/notes/:id'</span>, &#123;</span><br><span class="line">    id: <span class="string">'@id'</span>,</span><br><span class="line">    user: <span class="string">'@owner'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// note === &#123;id: 123, owner: 'alice', content: 'hello'&#125;</span></span><br><span class="line">note.$<span class="keyword">delete</span>();</span><br><span class="line"><span class="comment">// DELETE: /notes/123?user=alice</span></span><br></pre></td></tr></table></figure>
<p><strong>REST操作的声明和调用中，多于的属性会成为URL Query</strong>。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Notes = $resouce(<span class="string">'/notes/:id'</span>, &#123;id: <span class="string">'@id'</span>&#125;, &#123;</span><br><span class="line">    update: &#123;method: <span class="string">'PUT'</span>, operator: <span class="string">'bob'</span>&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// note === &#123;id: 123, content: 'hello'&#125;</span></span><br><span class="line">note.$update(&#123;trusted: <span class="literal">true</span>&#125;);</span><br><span class="line"><span class="comment">// PUT: /notes/123?operator=bob&amp;trusted=true &#123;id: 123, content: 'hello'&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="u54CD_u5E94_u8F6C_u6362"><a href="#u54CD_u5E94_u8F6C_u6362" class="headerlink" title="响应转换"></a>响应转换</h2><p>有时基于既定的后台设计，无法提供完全RESTful的API，比如/notes返回的是一个分页器对象，而非数组。此时，我们仍然可以使用<code>$resource</code>，但需要设置响应转换回调。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Notes = $resouce(<span class="string">'/notes/:id'</span>, <span class="literal">null</span>, &#123;</span><br><span class="line">    pager: &#123;</span><br><span class="line">        method: <span class="string">'GET'</span>,</span><br><span class="line">        transformResponse: <span class="function"><span class="keyword">function</span>(<span class="params">data, headers</span>)</span>&#123;</span><br><span class="line">            <span class="comment">// Server respond:</span></span><br><span class="line">            <span class="comment">// data = &#123;currentPage: 1,</span></span><br><span class="line">            <span class="comment">//    totalPage: 20,</span></span><br><span class="line">            <span class="comment">//    pageSize: 2,</span></span><br><span class="line">            <span class="comment">//    content: [&#123;id: 1, content: 'hello'&#125;, &#123;id: 2, content: 'world'&#125;]&#125;</span></span><br><span class="line">            <span class="keyword">var</span> pager = <span class="built_in">JSON</span>.parse(data);</span><br><span class="line">            <span class="keyword">return</span> pager.content;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> notes = Notes.query(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// GET: /notes</span></span><br><span class="line">    <span class="comment">// notes === [&#123;id: 1, content: 'hello'&#125;, &#123;id: 2, content: 'world'&#125;]</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>类似响应重写，你还可以设置请求转换<code>transformRequest</code>。</p>
<div class="tip">虽然<code>$resource</code>的设计可以支持绝大多数的URL和内容表示设计，但如果你发现<code>$resource</code>的使用过程极其复杂，那可能是你的服务器API并不满足RESTful风格。</div>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>REF:<br><a href="https://docs.angularjs.org/api/ngResource/service/$resource">AngularJS Document</a><br><a href="http://harttle.com/2015/06/05/angular-resource.html">http://harttle.com/2015/06/05/angular-resource.html</a></p>
</blockquote>
<p><a href="https://zh.wikipedia.org/zh-cn/REST">REST</a>（表征性状态传输，Representational State Transfer）是Roy Fielding博士在2000年他的博士论文中提出来的一种软件架构风格。RESTful风格的设计不仅具有更好的可读性（Human Readable），而且易于做缓存以及服务器扩展（scalability）。REST风格体现在URL设计上：</p>
<ul>
<li>每个URL对应一个资源</li>
<li>对资源的不同操作对应于HTTP的不同方法</li>
<li>资源表现形式（representation）通过<code>Accept</code>和<code>Content-Type</code>指定<br>AngularJS提供了$resourceService来更方便地与RESTful服务器API进行交互，可以方便地定义一个REST资源，而不必手动所有的声明CRUD方法。]]>
    
    </summary>
    
      <category term="AngularJS" scheme="http://leonewang.wang/tags/angularjs/"/>
    
      <category term="JavaScript" scheme="http://leonewang.wang/tags/javascript/"/>
    
      <category term="RESTful" scheme="http://leonewang.wang/tags/restful/"/>
    
      <category term="Notes" scheme="http://leonewang.wang/categories/notes/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Think About JavaScript『prototype and Prototype Chain』]]></title>
    <link href="http://leonewang.wang/2015/12/15/think-about-javascript-prototype-and-prototype-chain/"/>
    <id>http://leonewang.wang/2015/12/15/think-about-javascript-prototype-and-prototype-chain/</id>
    <published>2015-12-15T05:29:24.000Z</published>
    <updated>2015-12-15T05:29:24.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u666E_u901A_u5BF9_u8C61_u4E0E_u51FD_u6570_u5BF9_u8C61"><a href="#u666E_u901A_u5BF9_u8C61_u4E0E_u51FD_u6570_u5BF9_u8C61" class="headerlink" title="普通对象与函数对象"></a>普通对象与函数对象</h2><p>JavaScript 中，万物皆对象！但对象也是有区别的。分为普通对象和函数对象，Object ，Function 是JS自带的函数对象。下面举例说明。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"> <span class="keyword">var</span> f2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"> <span class="keyword">var</span> f3 = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'str'</span>,<span class="string">'console.log(str)'</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> o1 = &#123;&#125;;</span><br><span class="line"> <span class="keyword">var</span> o2 =<span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"> <span class="keyword">var</span> o3 = <span class="keyword">new</span> f1();</span><br><span class="line"></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Object</span>); <span class="comment">//function</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>); <span class="comment">//function</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">typeof</span> o1); <span class="comment">//object</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">typeof</span> o2); <span class="comment">//object</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">typeof</span> o3); <span class="comment">//object</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">typeof</span> f1); <span class="comment">//function</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">typeof</span> f2); <span class="comment">//function</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">typeof</span> f3); <span class="comment">//function</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>  在上面的例子中 <code>o1 o2 o3</code> 为普通对象，<code>f1 f2 f3</code> 为函数对象。怎么区分，其实很简单，<strong>凡是通过 <code>new Function()</code> 创建的对象都是函数对象</strong>，其他的都是普通对象。f1,f2,归根结底都是通过 <code>new Function()</code>的方式进行创建的。<strong>Function Object 也都是通过<code>New Function()</code>创建的</strong>。</p>
<h2 id="u539F_u578B_u5BF9_u8C61"><a href="#u539F_u578B_u5BF9_u8C61" class="headerlink" title="原型对象"></a>原型对象</h2><p> 在JavaScript 中，每当定义一个对象（函数）时候，对象中都会包含一些预定义的属性。其中函数对象的一个属性就是原型对象<code>prototype</code>。注：普通对象没有prototype,但有<code>__proto__</code>属性。</p>
<p>  原型对象其实就是普通对象（<strong>Function.prototype除外,它是函数对象，但它很特殊，他没有prototype属性（前面说道函数对象都有prototype属性）</strong>）。看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"> <span class="built_in">console</span>.log(f1.prototype) <span class="comment">//f1&#123;&#125;</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">typeof</span> f1. prototype) <span class="comment">//Object</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>.prototype) <span class="comment">// Function，这个特殊</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Object</span>.prototype) <span class="comment">// Object</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>.prototype.prototype) <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<p> 从这句<code>console.log(f1.prototype) //f1 {}</code> 的输出就结果可以看出，<code>f1.prototype</code>就是f1的一个实例对象。<strong>就是在f1创建的时候,创建了一个它的实例对象并赋值给它的prototype</strong>，基本过程如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> temp = <span class="keyword">new</span> f1();</span><br><span class="line">f1. prototype = temp;</span><br></pre></td></tr></table></figure>
<p>  所以，<code>Function.prototype</code>为什么是函数对象就迎刃而解了，上文提到凡是new Function ()产生的对象都是函数对象，所以temp1是函数对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> temp1 = <span class="keyword">new</span> <span class="built_in">Function</span> ();</span><br><span class="line"><span class="built_in">Function</span>.prototype = temp1;</span><br></pre></td></tr></table></figure>
<p>上篇 <a href="http://leonewang.wang/2015/10/23/think-about-javascript-this-pointer/"> <em>this 指针理解</em> </a> 中提到：如果在一个函数前面带上<code>new</code>关键字来调用，那么JavaScript会给这个函数添加一个<code>prototype</code>属性，并创建一个新对象，同时在调用这个函数时将<code>this</code>指针绑定到这个对象上，那么为什么<code>this</code>指针会绑定到新对象？</p>
<p>这里你又需要明确一点：<code>new constrcut()</code>是一种创建对象的语法糖，它等价于：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> person(<span class="string">"deen"</span>);</span><br><span class="line"><span class="comment">//通过new创建了一个对象</span></span><br><span class="line"><span class="comment">//new是一种语法糖，new person等价于</span></span><br><span class="line"><span class="keyword">var</span> bar = (<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _newObj = &#123;</span><br><span class="line">       constructor : person,</span><br><span class="line">       __proto__ : person.prototype,</span><br><span class="line">   &#125;;</span><br><span class="line">   _newObj.constructor(name);</span><br><span class="line">   <span class="comment">// _newObj.constructor.call(_newObj, name)</span></span><br><span class="line">   <span class="keyword">return</span> _newObj;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>那原型对象是用来做什么的呢？主要作用是用于<strong>继承</strong>。举了例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line"> &#125;;</span><br><span class="line"> person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">var</span> zjh = <span class="keyword">new</span> person(<span class="string">'zjh'</span>);</span><br><span class="line"> zjh.getName(); <span class="comment">//zjh</span></span><br></pre></td></tr></table></figure>
<p>从这个例子可以看出，通过给<code>person.prototype</code>设置了一个函数对象的属性，那样person实例（例中：zjh）出来的普通对象就继承了这个属性。具体是怎么实现的继承，就要讲到下面的原型链了。</p>
<h2 id="u539F_u578B_u94FE"><a href="#u539F_u578B_u94FE" class="headerlink" title="原型链"></a>原型链</h2><p>JS在创建对象（不论是普通对象还是函数对象）的时候，都有一个叫做<code>__proto__</code>的内置属性，<strong>用于指向创建它的函数对象的原型对象prototype</strong>。以上面的例子为例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(zjh.__proto__ === person.prototype) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>同样，person.prototype对象也有<code>__proto__</code>属性，它指向创建它的函数对象（Object）的prototype</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person.prototype.__proto__ === <span class="built_in">Object</span>.prototype) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>继续，Object.prototype对象也有<code>__proto__</code>属性，但它比较特殊，为null</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__) <span class="comment">//null</span></span><br></pre></td></tr></table></figure>
<p>我们把这个<strong>有<code>__proto__</code>串起来的直到<code>Object.prototype.__proto__</code>为null的链叫做原型链</strong>。如下图：</p>
<p><img src="http://7xpp7u.com1.z0.glb.clouddn.com/prototype-1.jpg" alt="prototype-1"></p>
<h2 id="u5185_u5B58_u7ED3_u6784_u56FE"><a href="#u5185_u5B58_u7ED3_u6784_u56FE" class="headerlink" title="内存结构图"></a>内存结构图</h2><p>为了更加深入和直观的进行理解，下面我们画一下上面的<strong>内存结构图</strong>：</p>
<p><img src="http://7xpp7u.com1.z0.glb.clouddn.com/prototype-2.jpg" alt="prototype-2"></p>
<p><strong>画图约定</strong>：</p>
<p><img src="http://7xpp7u.com1.z0.glb.clouddn.com/prototype-3.jpg" alt="prototype-3"></p>
<p><strong>疑点解释</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>Object是函数对象，是通过new Function()创建，所以<code>Object.__proto__</code>指向<code>Function.prototype</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>Function 也是对象函数，也是通过new Function()创建，所以<code>Function.__proto__</code>指向<code>Function.prototype</code>。</p>
<blockquote>
<p>自己是由自己创建的，好像不符合逻辑，但仔细想想，现实世界也有些类似，你是怎么来的，你妈生的，你妈怎么来的，你姥姥生的，……类人猿进化来的，那类人猿从哪来，一直追溯下去……，就是无，（NULL生万物）。正如《道德经》里所说“无，名天地之始”。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>其实这一点我也有点困惑，不过也可以试着解释一下。<br><strong>Function.prototype</strong> 是个函数对象，理论上他的<code>__proto__</code>应该指向 <code>Function.prototype</code>，就是他自己，自己指向自己，没有意义。<br>JS一直强调万物皆对象，函数对象也是对象，给他认个祖宗，指向<code>Object.prototype。Object.prototype.__proto__ === null</code>，保证原型链能够正常结束。</p>
<h2 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h2><p>原型对象prototype中都有个预定义的<strong>constructor</strong>属性，用来引用它的函数对象。这是一种循环引用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">person.prototype.constructor === person <span class="comment">//true</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.constructor === <span class="built_in">Function</span> <span class="comment">//true</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.constructor === <span class="built_in">Object</span> <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>完善下上面的内存结构图：</p>
<p><img src="http://7xpp7u.com1.z0.glb.clouddn.com/prototype-4.jpg" alt="prototype-4"></p>
<p>有两点需要注意：</p>
<ol>
<li>注意<code>Object.constructor===Function；//true</code> <strong>本身Object就是Function函数构造出来的</strong></li>
<li>如何<strong>查找</strong>一个对象的constructor，就是在该对象的原型链上<strong>寻找碰到的第一个constructor属性所指向的对象</strong></li>
</ol>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><ol>
<li>原型和原型链是JS实现继承的一种模型。</li>
<li>原型链的形成是真正是靠<strong><strong>proto</strong> 而非prototype</strong></li>
</ol>
<p>要深入理解这句话，我们再举个例子，看看前面你真的理解了吗？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> animal = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> dog = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  animal.price = <span class="number">2000</span>;</span><br><span class="line">  dog.prototype = animal;</span><br><span class="line">  <span class="keyword">var</span> tidy = <span class="keyword">new</span> dog();</span><br><span class="line">  <span class="comment">// tiny.__proto__ 指向 dog.prototype</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(dog.price) <span class="comment">//undefined</span></span><br><span class="line">  <span class="built_in">console</span>.log(tidy.price) <span class="comment">// 2000</span></span><br></pre></td></tr></table></figure>
<p>为什么呢？画一下内存图：</p>
<p><img src="http://7xpp7u.com1.z0.glb.clouddn.com/prototype-5.jpg" alt="prototype-5"></p>
<p>这说明什么问题呢，执行dog.price的时候，发现没有price这个属性，<strong>虽然prototype指向的animal有这个属性，但它并没有去沿着这个“链”去寻找</strong>。同样，执行tidy.price的时候，也没有这个属性，但是<code>__proto__</code>指向了animal，它会沿着这个链去寻找，animal中有price属性，所以tidy.price输出2000。由此得出，原型链的真正形成是靠的<strong><strong>proro</strong></strong>，而不是prototype。<br>因此，如果在这样指定<code>dog.__proto__ = animal</code>。那<code>dog.price = 2000</code>。</p>
<p>最后打个比喻，虽然不是很确切，但可能对原型的理解有些帮助。</p>
<p><img src="http://7xpp7u.com1.z0.glb.clouddn.com/prototype-6.jpg" alt="prototype-6"></p>
<p>父亲（函数对象），先生了一个大儿子（<strong>prototype</strong>），也就是你大哥，父亲给你大哥买了好多的玩具，当你出生的时候，你们之间的亲情纽带（<strong><strong>proto</strong></strong>）会让你自然而然的拥有了你大哥的玩具。同样，你也先生个大儿子，又给他买了好多的玩具，当你再生儿子的时候，你的小儿子会自然拥有你大儿子的所有玩具。至于他们会不会打架，这不是我们的事了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u666E_u901A_u5BF9_u8C61_u4E0E_u51FD_u6570_u5BF9_u8C61"><a href="#u666E_u901A_u5BF9_u8C61_u4E0E_u51FD_u6570_u5BF9_u8C61" class="headerlink" title="普通对象与函数对象"></a>普通对象与函数对象</h2><p>JavaScript 中，万物皆对象！但对象也是有区别的。分为普通对象和函数对象，Object ，Function 是JS自带的函数对象。下面举例说明。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"> <span class="keyword">var</span> f2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"> <span class="keyword">var</span> f3 = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'str'</span>,<span class="string">'console.log(str)'</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> o1 = &#123;&#125;;</span><br><span class="line"> <span class="keyword">var</span> o2 =<span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"> <span class="keyword">var</span> o3 = <span class="keyword">new</span> f1();</span><br><span class="line"></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Object</span>); <span class="comment">//function</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>); <span class="comment">//function</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">typeof</span> o1); <span class="comment">//object</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">typeof</span> o2); <span class="comment">//object</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">typeof</span> o3); <span class="comment">//object</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">typeof</span> f1); <span class="comment">//function</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">typeof</span> f2); <span class="comment">//function</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">typeof</span> f3); <span class="comment">//function</span></span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://leonewang.wang/tags/javascript/"/>
    
      <category term="prototype" scheme="http://leonewang.wang/tags/prototype/"/>
    
      <category term="Summarize" scheme="http://leonewang.wang/categories/summarize/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Question Shredder: JSP Analysis to HTML Incomplete]]></title>
    <link href="http://leonewang.wang/2015/11/09/q-jsp-loaded-incomplete/"/>
    <id>http://leonewang.wang/2015/11/09/q-jsp-loaded-incomplete/</id>
    <published>2015-11-09T07:20:53.000Z</published>
    <updated>2015-11-09T07:20:53.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u95EE_u9898_u63CF_u8FF0"><a href="#u95EE_u9898_u63CF_u8FF0" class="headerlink" title="问题描述"></a>问题描述</h2><p>jsp 解析后 <strong>html页面加载不完整</strong>，把前面的代码删一点后面的就跟着多加载一点</p>
<h2 id="u73AF_u5883"><a href="#u73AF_u5883" class="headerlink" title="环境"></a>环境</h2><p><code>Tomcat7</code> + <code>JDK7</code></p>
<a id="more"></a>
<p><a href="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/11/屏幕快照-2015-11-09-16.20.12.png" target="_blank" rel="external"><img src="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/11/屏幕快照-2015-11-09-16.20.12-1020x647.png" alt="2015-11-09 16.20.12"></a></p>
<h2 id="u76F4_u63A5_u539F_u56E0"><a href="#u76F4_u63A5_u539F_u56E0" class="headerlink" title="直接原因"></a>直接原因</h2><p>jsp页面中调用的java代码出现了异常，<code>java.lang.ArrayIndexOutOfBoundsException</code>，<strong>数组下标越界错误</strong>，未考虑到某些因素导致数组初始值大小错误。</p>
<h2 id="u5F52_u7EB3_u5176_u4ED6_u539F_u56E0"><a href="#u5F52_u7EB3_u5176_u4ED6_u539F_u56E0" class="headerlink" title="归纳其他原因"></a>归纳其他原因</h2><ul>
<li><p>jsp 缓存大小问题，在 jsp 页面中，默认是 autoFlush=”true”，也就是</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">%@</span> <span class="attribute">page</span> <span class="attribute">contentType</span>=<span class="value">"text/html;charset=UTF-8"</span> <span class="attribute">autoFlush</span>=<span class="value">"true"</span><span class="value">%</span>&gt;</span>;</span><br></pre></td></tr></table></figure>
<p>但通常情况下只用写成</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">%@</span> <span class="attribute">page</span> <span class="attribute">contentType</span>=<span class="value">"text/html;charset=UTF-8"</span><span class="value">%</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>就默认为 <code>autoFlush=&quot;true&quot;</code>。）但也可能出现错误，这个时候很可能会报 <code>java.io.IOException: Error: JSP Buffer overflow</code> 的错误，表示 <strong>jsp 缓存大小</strong> 不够，所以就必须设置增大 jsp 的缓存大小，也就是如 <code>buffer=&quot;300kb&quot;</code> ，完整的如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">%@</span> <span class="attribute">page</span> <span class="attribute">contentType</span>=<span class="value">"text/html;charset=UTF-8"</span> <span class="attribute">autoFlush</span>=<span class="value">"false"</span> <span class="attribute">buffer</span>=<span class="value">"300kb"</span><span class="value">%</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>另外要注意</strong> 的是：buffer 的值设置的如果不够大，那么在显示数据的时候，由于没有足够的缓存会抛出一些异常，比如 <code>NullPointer</code> 错误等，这个时候并不是你程序出了错，只要将 buffer 值再设置得大一些到不再出错即可。如果还有 <code>outOfMemery</code> 异常，那么就需要调整 JVM 的内存大小了。</p>
</li>
<li><p>空指针异常。</p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u95EE_u9898_u63CF_u8FF0"><a href="#u95EE_u9898_u63CF_u8FF0" class="headerlink" title="问题描述"></a>问题描述</h2><p>jsp 解析后 <strong>html页面加载不完整</strong>，把前面的代码删一点后面的就跟着多加载一点</p>
<h2 id="u73AF_u5883"><a href="#u73AF_u5883" class="headerlink" title="环境"></a>环境</h2><p><code>Tomcat7</code> + <code>JDK7</code></p>]]>
    
    </summary>
    
      <category term="JSP" scheme="http://leonewang.wang/tags/jsp/"/>
    
      <category term="Question" scheme="http://leonewang.wang/tags/question/"/>
    
      <category term="Develop" scheme="http://leonewang.wang/categories/develop/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Think About JavaScript『this Pointer』]]></title>
    <link href="http://leonewang.wang/2015/10/23/think-about-javascript-this-pointer/"/>
    <id>http://leonewang.wang/2015/10/23/think-about-javascript-this-pointer/</id>
    <published>2015-10-23T13:30:22.000Z</published>
    <updated>2015-12-15T13:30:22.000Z</updated>
    <content type="html"><![CDATA[<p>说到<code>this</code>，就不得不提到<code>function</code>，<strong>正是由于调用function的对象不同，才导致了this的指向不同</strong>。所以以前老是去记忆每种调用function的情况所对应的this，因为情况有限而且很少，所以这当然是可行的——对于聪明人来说，所以我不得不思考另外一些方式来让我记住。</p>
<div class="tip">那么首先我们需要明确的一个事情是：<strong>function也是对象</strong>。同时我们还需要明确的一个事情是：<strong>function执行时是在某个特定的上下文中执行的</strong>。<a id="more"></a></div>

<p>那什么是上下文呢？打个比方，比如你练会了辟邪剑谱，那这时候你的掌门让你用辟邪剑谱砍人。如果仅仅是这样的话，你是没法完成这个任务的，因为你必须得知道要砍谁吧，其次去哪儿砍吧，那么是个地下通道还是一望无尽的大草原，要是地下通道你走路都困难，还怎么用辟邪剑谱呢对吧。这就是上下文，函数执行时它也需要一些额外的信息来支撑它的运行。</p>
<p>那么既然function是对象的话，就会有方法。而function中最核心的方法是 <code>call</code> 方法。因此我们就从这儿入手。</p>
<h2 id="call_u65B9_u6CD5"><a href="#call_u65B9_u6CD5" class="headerlink" title="call方法"></a>call方法</h2><p>先来看一下如何使用call方法:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">content</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"From "</span> + <span class="keyword">this</span> + <span class="string">": Hello "</span>+ content);</span><br><span class="line">&#125;</span><br><span class="line">say.call(<span class="string">"Bob"</span>, <span class="string">"World"</span>); <span class="comment">//==&gt; From Bob: Hello World</span></span><br></pre></td></tr></table></figure>
<p>接下来仔细分析一下call的用法：<br><strong>Step1:</strong> 把第二个到最后一个参数作为函数执行时要传入的参数<br><strong>Step2:</strong> 把函数执行时的this指向第一个参数<br><strong>Step3:</strong> 在上面这个特殊的上下文中执行函数</p>
<p>上面例子中，我们通过call方法，让say函数执行时的<code>this</code>指向”Bob”，然后把”World”作为参数传进去，所以输出结果是可以预见的。</p>
<p>js执行函数时会默认完成以上的步骤，你可以把直接调用函数理解为一种语法糖<br>比如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">word</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(world);</span><br><span class="line">&#125;</span><br><span class="line">say(<span class="string">"Hello world"</span>);</span><br><span class="line">say.call(<span class="built_in">window</span>, <span class="string">"Hello world"</span>);</span><br></pre></td></tr></table></figure>
<p>以上可以把<code>say(&quot;Hello world&quot;)</code>看做是<code>say.call(window,&quot;Hello world&quot;)</code>的语法糖。</p>
<p>这个结论非常关键。所以以后每次看见<code>functionName(xxx)</code>的时候，你需要马上在脑海中把它替换为<code>functionName.call(window,xxxx)</code>，这对你理解this的指向非常重要。不过也有例外，<strong>在ES5的strict mode中call的第一个参数不是window而是undefined</strong>。之后的例子我假设总是不在strictmode下，但你需要记住strictmode有一点儿不同。</p>
<p>对于匿名函数来说，上面的结论也是成立的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;)(<span class="string">"aa"</span>);</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;    </span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">&#125;).call(<span class="built_in">window</span>, <span class="string">"aa"</span>);</span><br></pre></td></tr></table></figure>
<p>函数作为对象的方法被调用，直接来看代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name : <span class="string">"caibirdme"</span>,</span><br><span class="line">    run : <span class="function"><span class="keyword">function</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">"has been running for over "</span>+ time+ <span class="string">" minutes"</span>);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">person.run(<span class="number">30</span>);</span><br><span class="line"><span class="comment">//==&gt; caibirdme has been running for over 30 minutes//等价于</span></span><br><span class="line">person.run.call(person, <span class="number">30</span>); <span class="comment">// the same</span></span><br></pre></td></tr></table></figure>
<p>你会发现这里call的第一个参数是person而不是window。当你明白了这两点，下意识地把函数调用翻译成<code>foo.call()</code>的形式，明确call的第一个参数，那基本上this的问题就难不住你了。</p>
<p>还是来举几个例子。<br>例一：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">thing</span>) </span>&#123;  </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span> + <span class="string">" says hello "</span> + thing);</span><br><span class="line">&#125;</span><br><span class="line">  person = &#123; name: <span class="string">"caibirdme"</span> &#125;  </span><br><span class="line">  person.hello = hello;</span><br><span class="line">  person.hello(<span class="string">"world"</span>)</span><br><span class="line"><span class="comment">// 相当于执行 person.hello.call(person, "world")</span></span><br><span class="line">hello(<span class="string">"world"</span>)</span><br><span class="line"><span class="comment">// 相当于执行 hello.call(window, "world")</span></span><br></pre></td></tr></table></figure>
<p>例二：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    x: <span class="number">20</span>,</span><br><span class="line">    f: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>.x); &#125;</span><br><span class="line">&#125;;</span><br><span class="line">    obj.f(); <span class="comment">// obj.f.call(obj)//==&gt; 20</span></span><br><span class="line">obj.innerobj = &#123;</span><br><span class="line">    x: <span class="number">30</span>,</span><br><span class="line">    f: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>.x); &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.innerobj.f();</span><br><span class="line"><span class="comment">// obj.innerobj.f.call(obj.innerobj)// ==&gt; 30</span></span><br></pre></td></tr></table></figure>
<p>例三：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    x: <span class="number">20</span>,</span><br><span class="line">    f: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.x); <span class="comment">//this equals obj</span></span><br><span class="line">                <span class="comment">// ==&gt; 20</span></span><br><span class="line">        <span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>.x); &#125;</span><br><span class="line">        foo();</span><br><span class="line">        <span class="comment">// foo.call(window)</span></span><br><span class="line">        <span class="comment">//foo中this被指定为window，所以==&gt; 10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.f();  <span class="comment">// obj.f.call(obj)// ==&gt; 20 10</span></span><br></pre></td></tr></table></figure>
<p>由例三引出一个非常common的问题，如果我想让foo输出20怎么办？这时候需要用到一点小技巧。</p>
<p>例四：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    x: <span class="number">20</span>,</span><br><span class="line">    f: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line"><span class="comment">//使用that保留当前函数执行上下文的this</span></span><br><span class="line">        <span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(that.x); &#125;</span><br><span class="line"><span class="comment">//此时foo函数中的this仍然指向window，但我们使用that取得obj</span></span><br><span class="line">        foo(); <span class="comment">// foo.call(window)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.f();</span><br><span class="line">obj.f.call(obj)<span class="comment">// ==&gt; 20 20</span></span><br></pre></td></tr></table></figure>
<p>再来一个稍微难一点点的(但其实用call替换法一点儿也不难)。</p>
<p>例五：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    x: <span class="number">20</span>,</span><br><span class="line">    f: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>.x); &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.f(); <span class="comment">// obj.f.call(obj)// ==&gt; 20</span></span><br><span class="line"><span class="keyword">var</span> fOut = obj.f;</span><br><span class="line">fOut();</span><br><span class="line"><span class="comment">// fOut.call(window)//==&gt; 10</span></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    x: <span class="number">30</span>,</span><br><span class="line">    f: obj.f</span><br><span class="line">&#125;</span><br><span class="line">obj2.f(); <span class="comment">// obj2.f.call(obj2)//==&gt; 30</span></span><br></pre></td></tr></table></figure>
<p>例五有些同学会可能出错的原因，是没有明确我上面说的：<strong>this是在执行是才会被确认的</strong>。他可能会认为说<code>obj.f</code>那个函数定义在obj里面，那this就该指向obj。如果看完这篇文章你还这么想的话，我会觉得我的表达水平太失败了……</p>
<h2 id="u6784_u9020_u51FD_u6570"><a href="#u6784_u9020_u51FD_u6570" class="headerlink" title="构造函数"></a>构造函数</h2><p>先看一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func person(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> caibirdme = <span class="keyword">new</span> person(<span class="string">"deen"</span>);</span><br><span class="line"><span class="comment">// caibirdme.name == deen</span></span><br></pre></td></tr></table></figure>
<p>我上面也说了，函数在用作构造函数时同样可以用call方法去代替，那这里怎么代替呢？<br>这里你又需要明确一点：<code>new constrcut()是一种创建对象的语法糖</code>，它等价于</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> person(<span class="string">"deen"</span>);</span><br><span class="line"><span class="comment">//通过new创建了一个对象</span></span><br><span class="line"><span class="comment">//new是一种语法糖，new person等价于</span></span><br><span class="line"><span class="keyword">var</span> bar = (<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _newObj = &#123;</span><br><span class="line">        constructor : person,</span><br><span class="line">        __proto__ : person.prototype,</span><br><span class="line">    &#125;;</span><br><span class="line">    _newObj.constructor(name);</span><br><span class="line">    <span class="comment">// _newObj.constructor.call(_newObj, name)</span></span><br><span class="line">    <span class="keyword">return</span> _newObj;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>So you can see……为什么new的时候this就指向新的对象了吧？</p>
<p>通过我这篇文章，我希望学会通过把一个函数调用替换成<code>funcName.call</code>的形式，从而理解运行时上下文中this到底指向谁。总结来说就是下面两个等价变形：</p>
<p><strong>foo() —&gt; foo.call(window)</strong><br><strong>obj.foo() –&gt; obj.foo.call(obj)</strong></p>
<p>只要理解以上两个变形，this就不再是问题啦！！希望我的这种方法对各位同学认识this有所帮助，不要再像我曾经一样掉入this的坑中。</p>
<p>总之：<code>this</code> 当前执行环境的上下文，<code>call</code> 和 <code>apply</code> 修改对象的上下文。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>说到<code>this</code>，就不得不提到<code>function</code>，<strong>正是由于调用function的对象不同，才导致了this的指向不同</strong>。所以以前老是去记忆每种调用function的情况所对应的this，因为情况有限而且很少，所以这当然是可行的——对于聪明人来说，所以我不得不思考另外一些方式来让我记住。</p>
<div class="tip">那么首先我们需要明确的一个事情是：<strong>function也是对象</strong>。同时我们还需要明确的一个事情是：<strong>function执行时是在某个特定的上下文中执行的</strong>。]]>
    
    </summary>
    
      <category term=".this" scheme="http://leonewang.wang/tags/this/"/>
    
      <category term="JavaScript" scheme="http://leonewang.wang/tags/javascript/"/>
    
      <category term="Summarize" scheme="http://leonewang.wang/categories/summarize/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[The Maximum Length of HTTP Get/Post Request]]></title>
    <link href="http://leonewang.wang/2015/09/23/http-getpost-max-length/"/>
    <id>http://leonewang.wang/2015/09/23/http-getpost-max-length/</id>
    <published>2015-09-23T15:27:56.000Z</published>
    <updated>2016-01-01T17:25:13.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>REF:<br><a href="http://blog.chinaunix.net/uid-26602509-id-4495786.html" target="_blank" rel="external">http://blog.chinaunix.net/uid-26602509-id-4495786.html</a><br><a href="https://developer.yahoo.com/performance/rules.html" target="_blank" rel="external">https://developer.yahoo.com/performance/rules.html</a></p>
</blockquote>
<h2 id="GET__u65B9_u6CD5_u957F_u5EA6_u9650_u5236"><a href="#GET__u65B9_u6CD5_u957F_u5EA6_u9650_u5236" class="headerlink" title="GET 方法长度限制"></a>GET 方法长度限制</h2><p>Http Get 方法提交的数据大小长度并没有限制，HTTP 协议规范没有对 URL 长度进行限制。这个限制是特定的浏览器及服务器对它的限制。</p>
<p>如：IE 对 URL 长度的限制是 2083 字节(2K + 35)。</p>
<p>下面就是对各种浏览器和服务器的最大处理能力做一些说明.</p>
<a id="more"></a>
<p>Microsoft Internet Explorer (Browser)<br>IE 浏览器对 URL 的最大限制为 2,083 个字符，如果超过这个数字，提交按钮没有任何反应。</p>
<p>Firefox (Browser)<br>对于 Firefox 浏览器 URL 的长度限制为 65,536 个字符。</p>
<p>Safari (Browser)<br>URL 最大长度限制为 80,000 个字符。</p>
<p>Opera (Browser)<br>UR L最大长度限制为 190,000 个字符。</p>
<p>Google (chrome)<br>URL 最大长度限制为 8,182 个字符。</p>
<p>Apache (Server)<br>能接受最大 url 长度为 8,192 个字符。</p>
<p>Microsoft Internet Information Server(IIS)<br>能接受最大 url 的长度为 16,384 个字符。</p>
<p>通过上面的数据可知，为了让所有的用户都能正常浏览， URL 最好不要超过 IE 的最大长度限制(2083 个字符），当然，如果 URL 不直接提供给用户，而是提供给程序调用，这时的长度就只受 Web 服务器影响了。</p>
<p>注：对于中文的传递，最终会为 <code>urlencode</code> 后的编码形式进行传递，如果浏览器的编码为 UTF8 的话，一个汉字最终编码后的字符长度为 9 个字符。</p>
<h2 id="POST__u65B9_u6CD5_u957F_u5EA6_u9650_u5236"><a href="#POST__u65B9_u6CD5_u957F_u5EA6_u9650_u5236" class="headerlink" title="POST 方法长度限制"></a>POST 方法长度限制</h2><p>理论上讲，POST 是没有大小限制的。HTTP协议规范也没有进行大小限制，起限制作用的是服务器的处理程序的处理能力。<br>如：在 Tomcat 下取消 POST 大小的限制（Tomcat 默认 2M）；</p>
<p>打开 tomcat 目录下的 conf 目录，打开 server.xml 文件，修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debug=&#34;0&#34;&#10;acceptCount=&#34;100&#34;&#10;connectionTimeout=&#34;20000&#34;&#10;disableUploadTimeout=&#34;true&#34;&#10;port=&#34;8080&#34;&#10;redirectPort=&#34;8443&#34;&#10;enableLookups=&#34;false&#34;&#10;minSpareThreads=&#34;25&#34;&#10;maxSpareThreads=&#34;75&#34;&#10;maxThreads=&#34;150&#34;&#10;maxPostSize=&#34;0&#34;&#10;URIEncoding=&#34;GBK&#34;</span><br></pre></td></tr></table></figure>
<p>增加部分 <code>maxPostSize=&quot;0&quot;</code> (设为 0 是取消 POST 的大小限制)</p>
<h2 id="HTTP__u534F_u8BAE_u4ECE_u672A_u9650_u5236GET/POST__u7684_u8BF7_u6C42_u957F_u5EA6"><a href="#HTTP__u534F_u8BAE_u4ECE_u672A_u9650_u5236GET/POST__u7684_u8BF7_u6C42_u957F_u5EA6" class="headerlink" title="HTTP 协议从未限制GET/POST 的请求长度"></a>HTTP 协议从未限制GET/POST 的请求长度</h2><blockquote>
<p>The HTTP protocol does not place any a priori limit on the length of a URI. Servers MUST be able to handle the URI of any resource they serve, and SHOULD be able to handle URIs of unbounded length if they provide GET-based forms that could generate such URIs. A server SHOULD return 414 (Request-URI Too Long) status if a URI is longer than the server can handle (see section 10.4.15).</p>
<p>Note: Servers ought to be cautious about depending on URI lengths above 255 bytes, because some older client or proxy implementations might not properly support these lengths.</p>
</blockquote>
<p>所谓的请求长度限制室友浏览器和 web 服务器决定和设置的，各种浏览器和 web 服务器的设定均不一样，这依赖于各个浏览器厂家的规定或者根据 web 服务器的处理能力来设定。</p>
<blockquote>
<p>The limit is in MSIE and Safari about 2KB, in Opera about 4KB and in Firefox about 8KB, (255 bytes if we count very old browsers) . We may thus assume that 8KB is the maximum possible length and that 2KB is a more affordable length to rely on at the server side and that 255 bytes is the safest length to assume that the entire URL will come in.</p>
<p>If the limit is exceeded in either the browser or the server, most will just truncate the characters outside the limit without any warning. Some servers however may send a HTTP 414 error. If you need to send large data, then better use POST instead of GET. Its limit is much higher, but more dependent on the server used than the client. Usually up to around 2GB is allowed by the average webserver. This is also configureable somewhere in the server settings. The average server will display a server-specific error/exception when the POST limit is exceeded, usually as HTTP 500 error.</p>
<p>HTTP 1.1 defines Status Code 414 Request-URI Too Long for the cases where a server-defined limit is reached. You can see further details on RFC 2616. For the case of client-defined limits, there is no sense on the server returning something, because the server won’t receive the request at all.</p>
<p>The server is refusing to service the request because the Request-URI is longer than the server is willing to interpret. This rare condition is only likely to occur when a client has improperly converted a POST request to a GET request with long query information, when the client has descended into a URI “black hole” of redirection (e.g., a redirected URI prefix that points to a suffix of itself), or when the server is under attack by a client attempting to exploit security holes present in some servers using fixed-length buffers for reading or manipulating the Request-URI.</p>
</blockquote>
<h2 id="GET_VS_POST"><a href="#GET_VS_POST" class="headerlink" title="GET VS POST"></a>GET VS POST</h2><ol>
<li>多数浏览器对于 POST 采用两阶段发送数据的，先发送请求头，再发送请求体，即使参数再少再短，也会被分成两个步骤来发送（相对于 GET），也就是第一步发送 header 数据，第二步再发送 body 部分。HTTP 是应用层的协议，而在传输层有些情况 TCP 会出现两次连结的过程，HTTP 协议本身不保存状态信息，一次请求一次响应。对于 TCP 而言，通信次数越多反而靠性越低，能在一次连结中传输完需要的消息是最可靠的，尽量使用 GET 请求来减少网络耗时。如果通信时间增加，这段时间客户端与服务器端一直保持连接状态，在服务器侧负载可能会增加，可靠性会下降。</li>
</ol>
<p><a href="http://blogread.cn/it/article/6100?f=wb" target="_blank" rel="external">YSLOW 法则中，为什么 yahoo 推荐用 GET 代替 POST ？</a></p>
<ol>
<li>GET 参数是带在 URL 后面，传统 IE 中 URL 的最大可用长度为 2048 字符，其他浏览器对 URL 长度限制实现上有所不同。POST 请求无长度限制（目前理论上是这样的）。<p></p></li>
<li>由于 GET 参数是在 URL 后面，所以 GET 请求能够被 Cache，GET 请求能够缓存在浏览器的历史记录中，而 POST 不进行缓存，所以重要、私密数据的提交要避免使用 GET 请求。<p></p></li>
<li>GET 提交的数据大小，不同浏览器的限制不同，一般在 2k-8K 之间，POST 提交数据比较大，大小靠服务器的设定值限制，而且某些数据只能用 POST 方法「携带」，比如 file。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>REF:<br><a href="http://blog.chinaunix.net/uid-26602509-id-4495786.html">http://blog.chinaunix.net/uid-26602509-id-4495786.html</a><br><a href="https://developer.yahoo.com/performance/rules.html">https://developer.yahoo.com/performance/rules.html</a></p>
</blockquote>
<h2 id="GET__u65B9_u6CD5_u957F_u5EA6_u9650_u5236"><a href="#GET__u65B9_u6CD5_u957F_u5EA6_u9650_u5236" class="headerlink" title="GET 方法长度限制"></a>GET 方法长度限制</h2><p>Http Get 方法提交的数据大小长度并没有限制，HTTP 协议规范没有对 URL 长度进行限制。这个限制是特定的浏览器及服务器对它的限制。</p>
<p>如：IE 对 URL 长度的限制是 2083 字节(2K + 35)。</p>
<p>下面就是对各种浏览器和服务器的最大处理能力做一些说明.</p>]]>
    
    </summary>
    
      <category term="GET/POST" scheme="http://leonewang.wang/tags/get-post/"/>
    
      <category term="HTTP" scheme="http://leonewang.wang/tags/http/"/>
    
      <category term="Request" scheme="http://leonewang.wang/tags/request/"/>
    
      <category term="Summarize" scheme="http://leonewang.wang/categories/summarize/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[远赴边陲？江西的北国 — 武功山]]></title>
    <link href="http://leonewang.wang/2015/09/21/jiangxiwugong-mountain/"/>
    <id>http://leonewang.wang/2015/09/21/jiangxiwugong-mountain/</id>
    <published>2015-09-21T02:35:54.000Z</published>
    <updated>2015-09-21T02:35:54.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/09/IMG_0069.jpg" target="_blank" rel="external"><img src="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/09/IMG_0069-1020x366.jpg" alt="IMG_0069"></a></p>
<blockquote>
<p>徐霞客，早在377年前，就游览了武功山，留下了《游武功山日记》一文，并收录在《徐霞客游记》 一书中。现如今，越来越多的驴友关注武功山，每年有数以万计的驴友在界上驴行。在户外圈中有“北太白、南武功”一说，并被《中国国家地理杂志》，评为“中国十大非著名山峰”。</p>
</blockquote>
<p>自汉晋起，武功山被道佛两家择为修身养性之洞天福地，明朝时香火达到鼎盛时期，山南山北建进了庵、堂、寺、观达100多处，无数善男信女到此朝拜。自唐宋以来，诸多仰慕其名而登山游赏吟诗作赋的名人学士络绎不绝，留下了无数珍贵墨迹。<br><a id="more"></a><br>武功山横跨江西萍乡市芦溪县、吉安市安福县、宜春市袁州区（萍乡市内武功山区称为萍乡武功山，安福县内称为安福武功山或福山，而宜春市内称为明月山或日月山），地处罗霄山脉北段，横亘湘赣两省，绵延起伏120余公里，总面积970多平方公里，主峰金顶白鹤峰海拔1918.3米，为江西省境内第一高峰。</p>
<p>武功山有世界同纬度海拔最高、面积最大的高山草甸，还有上千处瀑布，非常适合户外露营和穿越，是全国驴友心中的户外天堂。武功山与庐山、衡山，并称“江南三大名山”，其草甸绵绵于高山之巅，穿云入雾，春夏绿油油，秋季金灿灿，冬天白皑皑，无需远赴边陲，便可领略北国风光。</p>
<p>初秋了，这时的武功山高山草甸想必也即将由绿转黄了，趁着天气不错叫上小伙伴带上帐篷开始了我们的武功山徒步之旅。因武功山目前还没有成熟的开发力度，许多驴友来武功山非常不便，当然了，正是人为开发力度较小，所以才有许多追求原生态的驴友想要去往体验一番，另外每年的九月份会在金顶举行帐篷节，非常壮观，所以下面为广大外地驴友提供一个线路以供参考。</p>
<p><strong>提醒事项</strong></p>
<ul>
<li>户外饮水是大事，人多时上山水源的补给不是问题，但是<strong>如果你是淡季上山，那么要注意带些碘酒或者净水药片</strong>，因为淡季时山上许多客栈是没有人的，所以很有可能买不到水，这时就需要自己净化一些山泉水喝了，每家客栈门前的水龙头都是通的山上的山泉，水很干净但以防万一，1L 水加一片药片或3-4滴碘酒静置一段时间后饮用。<p></p></li>
<li>行程的后三天都是走在山脊上，无数个上山下山在等着你，<strong>准备好双杖吧，注意脚下，一不小心可能就跌下山谷了</strong>。<p></p></li>
<li>Day4 时需要穿越大量灌木丛，面容姣好的孩子<strong>带好遮阳帽和遮纱，我就无所谓了，尽情地被灌木打脸就好了</strong>。<p></p></li>
<li><strong>山上风大，扎帐篷选好背风坡</strong>，避免风声太大睡不着。旅店老板人很好，让我们扎在旅店门口，让铁皮屋给挡挡风 <strong>&lt;(￣▽￣)&gt; 哇哈哈…</strong>。<p></p></li>
<li><p>如<strong>冬季出行或遇阴雨天</strong>，请务必准备好<strong>冰爪</strong>。</p>
</li>
<li><p>山上天气阴冷潮湿，尽量<strong>带件厚些的冲锋衣</strong>。九月的夜晚温度会降至10℃以下。想<strong>在外扎帐篷的驴友要带1.5kg 及以上的睡袋</strong>才行，具体按温标0℃-5℃买吧。（针对夏秋季）</p>
</li>
<li><p>一路树枝上均有户外俱乐部绑的红蓝黄布条，不要怕迷路，<strong>跟着布条走就行</strong>。另外，<strong>跟着垃圾走，看到路边没垃圾，立马回撤到岔口</strong>。为什么？你懂的！</p>
</li>
<li><p>所以，<strong>朋友们带个垃圾袋随身吧</strong>。</p>
</li>
<li><p>上界前一定要看<strong>天气预报</strong>，雨太大或者气温特高的话，尽量不要上界。一定要上界的话，就做好充分的准备，毕竟身体健康是爬山重要的保障。</p>
</li>
<li><p>买<strong>户外登山保险</strong>很有必要。</p>
</li>
</ul>
<h3 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a><code>Day1</code></h3><h4 id="u4ECA_u65E5_u884C_u7A0B_uFF1A_u5357_u660C__u2192__u840D_u4E61_u6C88_u5B50_u6751_u3002"><a href="#u4ECA_u65E5_u884C_u7A0B_uFF1A_u5357_u660C__u2192__u840D_u4E61_u6C88_u5B50_u6751_u3002" class="headerlink" title="今日行程：南昌 → 萍乡沈子村。"></a>今日行程：南昌 → 萍乡沈子村。</h4><p>从南昌出发，前往萍乡火车站，如果还有装备没有买齐的话，周围有许多户外店，山上可什么都没有。站前有汽车站，乘坐大巴直接前往武功山正门，如果人多的话，站前有许多的私家车，包车180RMB可以直接送到一个叫沈子村（萍乡市芦溪县新泉乡）的地方，我们这次选择的是后者，大约40分钟后，我们就到达了这次徒步的起点沈子村某旅社。休整一晚，第二天便可出发，走前建议向旅社老板问清路况。</p>
<h3 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a><code>Day2</code></h3><h4 id="u4ECA_u65E5_u884C_u7A0B_uFF1A_u6C88_u5B50_u6751__u2192__u94C1_u8E44_u5CF0__u2192__u91D1_u9876_uFF08__u2192__u767D_u4E91_u5BA2_u6808_uFF09_u3002_u5168_u7A0B_u957F_u5EA6_u7EA610_u516C_u91CC_uFF0C_u62D4_u9AD8_u7EA61300m_u3002"><a href="#u4ECA_u65E5_u884C_u7A0B_uFF1A_u6C88_u5B50_u6751__u2192__u94C1_u8E44_u5CF0__u2192__u91D1_u9876_uFF08__u2192__u767D_u4E91_u5BA2_u6808_uFF09_u3002_u5168_u7A0B_u957F_u5EA6_u7EA610_u516C_u91CC_uFF0C_u62D4_u9AD8_u7EA61300m_u3002" class="headerlink" title="今日行程：沈子村 → 铁蹄峰 → 金顶（ → 白云客栈）。全程长度约10公里，拔高约1300m。"></a>今日行程：沈子村 → 铁蹄峰 → 金顶（ → 白云客栈）。全程长度约10公里，拔高约1300m。</h4><p>沈子村这个地方并不是武功山的大道，驴友常称这种地方叫做“野道”，但是从这个地方出发，背着厚重的行李，伴着雨点，累的气喘吁吁的同时也能欣赏到别样的风景，那山，那水，那田园风光，仿佛置身于世外桃源之中。</p>
<p><a href="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/09/1398413726699_0.jpg" target="_blank" rel="external"><img src="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/09/1398413726699_0.jpg" alt="1398413726699_0"></a></p>
<p><a href="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/09/1398413688524_0.jpg" target="_blank" rel="external"><img src="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/09/1398413688524_0.jpg" alt="1398413688524_0"></a></p>
<p>如果运气好的话，在铁蹄峰上就可以看到传说中的云海了。</p>
<p><a href="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/09/IMG_0069.jpg" target="_blank" rel="external"><img src="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/09/IMG_0069-1020x366.jpg" alt="IMG_0069"></a></p>
<p>沈子村到金顶，需要攀爬两座高山和些许山坡，无水源，到金顶由于海拔拔高较快（海拔图中可看出），应控制速度，保持体力，到了中午找块平坦的石头就坐下吃点干粮补充体力，全程徒步时间约6-8小时，每人带2L水便可应付本路段。</p>
<p>出发半小时后可以看见配电站，在配电站前有一间荒废的屋子，在屋子的右侧有非常隐蔽的贴墙小路，所幸这次我们碰到了两位来过多次的驴友，才找到了这个“桃园引道”。之后5-6小时后便能到达铁蹄峰，如果走岔道了，那么很有可能绕路经过九龙山，再到铁蹄峰，不过这段路的行程较直接前往铁蹄峰要相对平缓些，但是路程要延长3-5公里，且据沈子村的村民说风景不如前者，所以一般到了岔口就跟着布条走就不会走错。</p>
<p>到达铁蹄峰客栈后再走一个小时就能到达最高峰金顶了，这次去的时候金顶上正在施工建游道，石碑也在某年被雷击碎了，虽然没有看见石碑，但是碰到了一群欢乐的小伙伴，也是一种慰藉了。</p>
<p><a href="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/09/IMG_0282.jpg" target="_blank" rel="external"><img src="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/09/IMG_0282-1020x863.jpg" alt="IMG_0282"></a></p>
<p><a href="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/09/IMG_0293.jpg" target="_blank" rel="external"><img src="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/09/IMG_0293-1020x765.jpg" alt="IMG_0293"></a></p>
<p>如果赶上帐篷节，可以继续前往白云客栈入住，此处为帐篷节的大本营。</p>
<p>由金顶至白云客栈全程约3公里，有近1公里的游道，还有约2公里的简易便道（以松木为台阶边缘，以大石头和泥土混合压平成台阶形状，以楠竹做护栏）。从金顶至吊马桩全程游道，吊马桩口有岔路，沿游道下至中庵，沿简易便道可到达白云客栈。</p>
<h3 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a><code>Day3</code></h3><h4 id="u4ECA_u65E5_u884C_u7A0B_uFF1A_u91D1_u9876_uFF08__u2192__u767D_u4E91_u5BA2_u6808_uFF09__u2192__u7EDD_u671B_u5761__u2192__u597D_u6C49_u5761__u2192__u6B66_u53D1_u5C71_u5E84__u2192__u98CE_u8F66_u53E3__u2192__u53D1_u4E91_u754C_u3002_u5168_u7A0B_u957F_u5EA6_u7EA612_u516C_u91CC_u3002"><a href="#u4ECA_u65E5_u884C_u7A0B_uFF1A_u91D1_u9876_uFF08__u2192__u767D_u4E91_u5BA2_u6808_uFF09__u2192__u7EDD_u671B_u5761__u2192__u597D_u6C49_u5761__u2192__u6B66_u53D1_u5C71_u5E84__u2192__u98CE_u8F66_u53E3__u2192__u53D1_u4E91_u754C_u3002_u5168_u7A0B_u957F_u5EA6_u7EA612_u516C_u91CC_u3002" class="headerlink" title="今日行程：金顶（ → 白云客栈） → 绝望坡 → 好汉坡 → 武发山庄 → 风车口 → 发云界。全程长度约12公里。"></a>今日行程：金顶（ → 白云客栈） → 绝望坡 → 好汉坡 → 武发山庄 → 风车口 → 发云界。全程长度约12公里。</h4><p>没错，今天的行程很 ~ 折磨人。全程耗时5-8小时，1700m以上的大山需要翻越3座，除了这3座大山之外还有很多小山，故不要期望靠着数山来捱完行程，会越数越失望，别忘了绝望坡还在等着你。</p>
<p>没关系，虽然今天很折磨人，但还是要生活不是，早上裹着睡袋、躺在帐篷里和小伙伴们看日出，一天的开始还是很惬意的。</p>
<p><a href="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/09/IMG_0113.jpg" target="_blank" rel="external"><img src="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/09/IMG_0113-1020x486.jpg" alt="IMG_0113"></a></p>
<p>金顶至发云界均在山脊线上行走，故客栈较多，可利用客栈门前的水龙头中的山泉水补给水源（提醒事项中有净化水源事项）。全线海拔起伏大，每座大山山峰山谷海拔落差均大于300m，而且每一个垭口缓冲较长，是考验意志力的路程，这一段风景亦是武功山的精华，各种矮松树，各种红黄绿的植被分外养眼，给力的是老天做美，时而起雾，时而散开，又时而半雾半晴，这些若隐若现的浓雾、薄雾穿插在金黄色的高山草甸中，人行走在此景此处，各种美感淋漓尽致，如同漫步在童话的世界里面，如梦如幻，需要你慢慢品味。</p>
<p><a href="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/09/IMG_0129.jpg" target="_blank" rel="external"><img src="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/09/IMG_0129-1020x1360.jpg" alt="IMG_0129"></a></p>
<p><a href="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/09/IMG_0156.jpg" target="_blank" rel="external"><img src="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/09/IMG_0156-1020x765.jpg" alt="IMG_0156"></a></p>
<p>另外，如果感觉第二天已经体力不支了，可以选择经过吊马桩后前往红岩谷（此处收门票）方向下山，因为有女生体力跟不上，于是在这里忍痛和小伙伴们分开，有缘再会。</p>
<p><a href="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/09/IMG_0281.jpg" target="_blank" rel="external"><img src="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/09/IMG_0281-1020x1038.jpg" alt="IMG_0281"></a></p>
<h3 id="Day4"><a href="#Day4" class="headerlink" title="Day4"></a><code>Day4</code></h3><h4 id="u4ECA_u65E5_u884C_u7A0B_uFF1A_u53D1_u4E91_u754C__u2192__u63D0_u4ED9_u5BFA__u2192__u6C88_u5BB6_u5927_u9662__u2192__u7F8A_u72EE_u5E55__u2192__u660E_u6708_u5C71_uFF08__u2192__u5B9C_u6625_uFF09_u3002_u5168_u7A0B_u957F_u5EA6_u7EA617_u516C_u91CC_u3002"><a href="#u4ECA_u65E5_u884C_u7A0B_uFF1A_u53D1_u4E91_u754C__u2192__u63D0_u4ED9_u5BFA__u2192__u6C88_u5BB6_u5927_u9662__u2192__u7F8A_u72EE_u5E55__u2192__u660E_u6708_u5C71_uFF08__u2192__u5B9C_u6625_uFF09_u3002_u5168_u7A0B_u957F_u5EA6_u7EA617_u516C_u91CC_u3002" class="headerlink" title="今日行程：发云界 → 提仙寺 → 沈家大院 → 羊狮幕 → 明月山（ → 宜春）。全程长度约17公里。"></a>今日行程：发云界 → 提仙寺 → 沈家大院 → 羊狮幕 → 明月山（ → 宜春）。全程长度约17公里。</h4><p>今天的路线很适合像我这种害怕蜘蛛等多足类昆虫的人来克服恐惧，反正我走完后回来敢打蟑螂了。</p>
<p>全程下坡居多，起伏较大，基本无危险地段。发云界出发1小时左右山地地貌突变，高山草甸强转成了灌木荆棘，之后将全线在灌木丛中穿行，身体裸露部分易划伤，建议长袖、长裤或者短袖带上防晒袖套、腿套。</p>
<p><a href="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/09/IMG_0178.jpg" target="_blank" rel="external"><img src="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/09/IMG_0178-1020x765.jpg" alt="IMG_0178"></a></p>
<p>腿上扎进去的倒刺。</p>
<p><a href="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/09/IMG_0168.jpg" target="_blank" rel="external"><img src="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/09/IMG_0168-1020x1360.jpg" alt="IMG_0168"></a></p>
<p><a href="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/09/IMG_0170.jpg" target="_blank" rel="external"><img src="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/09/IMG_0170-1020x1360.jpg" alt="IMG_0170"></a></p>
<p>比人高的灌木丛，道路非常窄，需要穿越大约2.5小时，遇到岔口后直走几分钟看到如下的石阶，恭喜，成功穿越灌木丛。</p>
<p><a href="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/09/IMG_0172.jpg" target="_blank" rel="external"><img src="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/09/IMG_0172-1020x1360.jpg" alt="IMG_0172"></a></p>
<p>下一段石阶后便是三岔路口，有块木牌上写着“羊狮幕景区”左转后上一段石阶即是报仙寺。</p>
<p><a href="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/09/IMG_0176.jpg" target="_blank" rel="external"><img src="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/09/IMG_0176-1020x765.jpg" alt="IMG_0176"></a></p>
<p>沿着报仙寺前的小路一路向前，之后很快便可到达沈家大院，往两个房子之间的缝隙穿过，右边有一木桥，上石阶上山。到达三岔路口后走大路，原本想走右边小路抄近路，但是灌木过于密集，已经走不通。</p>
<p><a href="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/09/IMG_0186.jpg" target="_blank" rel="external"><img src="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/09/IMG_0186-1020x1360.jpg" alt="IMG_0186"></a></p>
<p>登山杖在此路段就很难发挥作用，可以使用一根做探路用，另外可带上手套，便于下坡时抓树枝借力。<strong>登山杖的正确姿势，抡起在面前画圈，竹林里蜘蛛网实在太多，不然糊满脸。</strong></p>
<p><a href="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/09/IMG_0179.jpg" target="_blank" rel="external"><img src="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/09/IMG_0179-1020x1360.jpg" alt="IMG_0179"></a></p>
<p>由发云界到沈家大院全程约4-5小时，此路段无水源，提前备足。</p>
<p>从发云界到沈家大院的穿越线路可以用经典二个字来形容！既有深山峡谷的壮观，又有辽阔草原般的气势。山间小路时而弯入深谷，时而直上云霄，恍入天上人间，白云和薄雾就在脚边缓缓流动，入目之处是满山的青翠和映山红的娇艳。</p>
<p><a href="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/09/IMG_0191.jpg" target="_blank" rel="external"><img src="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/09/IMG_0191-1020x1360.jpg" alt="IMG_0191"></a></p>
<p>离开沈家大院后有一段当时看来非常漫长的竹栏石阶游步道，之后便到达了羊狮幕景区的东福门入口，此处售门票，成人票100，学生票50，正处于开发中期，许多景点设施都不完善，但是景区风光还是很好的。</p>
<p><a href="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/09/IMG_0201.jpg" target="_blank" rel="external"><img src="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/09/IMG_0201-1020x642.jpg" alt="IMG_0201"></a></p>
<p>下面是噱头之一的悬空栈道。</p>
<p><a href="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/09/IMG_0221.jpg" target="_blank" rel="external"><img src="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/09/IMG_0221-1020x1360.jpg" alt="IMG_0221"></a></p>
<p>游览完羊狮幕景区后前往地图中的流云台,询问此处的工作人员如何去搭乘羊狮幕到明月山的小火车。</p>
<p><a href="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/09/IMG_0237.jpg" target="_blank" rel="external"><img src="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/09/IMG_0237-1020x1360.jpg" alt="IMG_0237"></a></p>
<p>之后沿着工作人员指的道路下山走上公路，此段大约1小时。</p>
<p><a href="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/09/IMG_0263.jpg" target="_blank" rel="external"><img src="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/09/IMG_0263-1020x1360.jpg" alt="IMG_0263"></a></p>
<p>出了羊狮幕景区就可以看到小火车站了。</p>
<p><a href="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/09/IMG_0234.jpg" target="_blank" rel="external"><img src="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/09/IMG_0234-1020x765.jpg" alt="IMG_0234"></a></p>
<p>因为是淡季，于是乎100RMB包了辆火车╰(￣▽￣)╮。</p>
<p><a href="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/09/IMG_0256.jpg" target="_blank" rel="external"><img src="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/09/IMG_0256-1020x1360.jpg" alt="IMG_0256"></a></p>
<p>咔咔咔，20分钟到达明月山索道站上站，明月山至大门为盘山公路或石台阶，走公路无趣无风景，走台阶伤膝盖，可以选择乘坐索道下山，40分钟左右即可到达山脚，反正我从来没正常过，这次也没正常点坐索道，反正快结束了，和室友一路从游步道飞奔下山，两个小时到达大门。还是建议腿力、膝盖不好的朋友做索道下山，避免膝盖受伤，毕竟今天的徒步路程也比较远，下山游步道台阶数大约6000级，正常速度2-3小时。</p>
<p>这里有必要吐槽一下，明月山索道的上下行索道票竟然<strong>没有学生票！没有军人票！没有老弱孕票！</strong>连羊狮幕景区这刚开发的景区都有考虑到特殊人群，而明月山景区开发早已超过五年，却没有考虑到这点，而让人奇怪的是，明月山的门票却又考虑到了特殊人群，难道索道承包商有种劳资一家独大，你们爱做不做的心态？</p>
<ul>
<li>[x] 武功山</li>
</ul>
<p>整个行程结束，接下来就是前往火车站，准备回家。如果下山后比较早，直接乘坐公交车即可前往市区，如果下山时天色已晚，那么可以去附近的天沐泡泡温泉，休整一晚后打道回府。</p>
<p>嗯，还活着呢。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/09/IMG_0069.jpg"><img src="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/09/IMG_0069-1020x366.jpg" alt="IMG_0069"></a></p>
<blockquote>
<p>徐霞客，早在377年前，就游览了武功山，留下了《游武功山日记》一文，并收录在《徐霞客游记》 一书中。现如今，越来越多的驴友关注武功山，每年有数以万计的驴友在界上驴行。在户外圈中有“北太白、南武功”一说，并被《中国国家地理杂志》，评为“中国十大非著名山峰”。</p>
</blockquote>
<p>自汉晋起，武功山被道佛两家择为修身养性之洞天福地，明朝时香火达到鼎盛时期，山南山北建进了庵、堂、寺、观达100多处，无数善男信女到此朝拜。自唐宋以来，诸多仰慕其名而登山游赏吟诗作赋的名人学士络绎不绝，留下了无数珍贵墨迹。<br>]]>
    
    </summary>
    
      <category term="Mountaineering" scheme="http://leonewang.wang/tags/mountaineering/"/>
    
      <category term="Journey" scheme="http://leonewang.wang/categories/journey/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Think About JavaScript『prototype』]]></title>
    <link href="http://leonewang.wang/2015/09/02/think-about-javascript-prototype/"/>
    <id>http://leonewang.wang/2015/09/02/think-about-javascript-prototype/</id>
    <published>2015-09-02T08:19:04.000Z</published>
    <updated>2015-09-02T08:19:04.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>REF:<a href="http://www.liaoxuefeng.com/" target="_blank" rel="external">http://www.liaoxuefeng.com/</a> 的面向对象编程章节。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrimaryStudent</span>(<span class="params">grade</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.grade = grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.hello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Hello '</span> + <span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PrimaryStudent.prototype = <span class="keyword">new</span> Student(<span class="string">'xiaoming'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = <span class="keyword">new</span> PrimaryStudent(<span class="string">'xiaoming'</span>);</span><br><span class="line"></span><br><span class="line">xiaoming.hello();   <span class="comment">// Hello xiaoming</span></span><br><span class="line">alert(Student.prototype.isPrototypeOf(xiaoming));   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>原型链如图所示：</p>
<p><a href="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/09/屏幕快照-2015-09-02-16.22.51.png" target="_blank" rel="external"><img src="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/09/屏幕快照-2015-09-02-16.22.51.png" alt="屏幕快照 2015-09-02 16.22.51"></a></p>
<p>之前在学习 JavaScript 的时候就对原型对象的理解就已步入误区，首先要明确 <code>[[prototype]]</code> 和 <code>prototype</code> 是两种不一样的东西。</p>
<p>首先讲讲 <code>prototype</code>，每一个函数对象都有一个显式的 <code>prototype</code> 属性，代表了对象的原型，更具体的说是代表了函数对象 <strong>（JavaScript 中没有构造函数这一说法）</strong> 所创建的对象的原型。</p>
<p>以上例为例，<code>PrimaryStudent.prototype</code> 就是 <code>xiaoming</code> 的原型，<code>xiaoming</code> 所引用的那个由 <code>new PrimaryStudent()</code> 创建出来的对象将从 <code>PrimaryStudent.prototype</code> 所引用的对象中继承其属性与方法。</p>
<p>其次是 <code>[[prototype]]</code>，每一个对象都有一个隐藏的 <code>[[prototype]]</code> 内部属性，上例中，<code>xiaoming</code> 的 <code>[[prototype]]</code> 指向 <code>PrimaryStudent.prototype</code> ，而 <code>PrimaryStudent.prototype</code> 也是一个对象，所以它也有一个 <code>[[prototype]]</code> 属性指向它的原型对象，这便形成了一个 <strong>原型链</strong>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>REF:<a href="http://www.liaoxuefeng.com/">http://www.liaoxuefeng.com/</a> 的面向对象编程章节。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrimaryStudent</span>(<span class="params">grade</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.grade = grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.hello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Hello '</span> + <span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PrimaryStudent.prototype = <span class="keyword">new</span> Student(<span class="string">'xiaoming'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = <span class="keyword">new</span> PrimaryStudent(<span class="string">'xiaoming'</span>);</span><br><span class="line"></span><br><span class="line">xiaoming.hello();   <span class="comment">// Hello xiaoming</span></span><br><span class="line">alert(Student.prototype.isPrototypeOf(xiaoming));   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://leonewang.wang/tags/javascript/"/>
    
      <category term="Summarize" scheme="http://leonewang.wang/categories/summarize/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Ukulele]]></title>
    <link href="http://leonewang.wang/2015/08/17/ukulele/"/>
    <id>http://leonewang.wang/2015/08/17/ukulele/</id>
    <published>2015-08-17T08:59:56.000Z</published>
    <updated>2015-08-17T08:59:56.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>自从去年偶然发现了 <a href="http://walkofftheearth.com" target="_blank" rel="external">Walk off the Earth</a> 各种天马行空的 MV 之后，就一直觉得 Ukulele 弹奏有一种魔性的声音，欢快轻松，也是我非常喜欢的民谣风格，甚至摇滚风。</p>
</blockquote>
<a id="more"></a>
<p>昨天黄昏，和朋友们去曾厝垵步行街逛逛，结果发现了好几家 <code>Ukulele</code> 小店，瞬间就魔障了，心里痒痒的，想要淘一只来玩玩，虽说谈不上老鸟，但还是玩过会吉他，小U上手应该也很快，某猫买的彩虹人 ANueNue 子品牌 AQUA 23”</p>
<p>科普文化中</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>自从去年偶然发现了 <a href="http://walkofftheearth.com">Walk off the Earth</a> 各种天马行空的 MV 之后，就一直觉得 Ukulele 弹奏有一种魔性的声音，欢快轻松，也是我非常喜欢的民谣风格，甚至摇滚风。</p>
</blockquote>]]>
    
    </summary>
    
      <category term="Ukulele" scheme="http://leonewang.wang/tags/ukulele/"/>
    
      <category term="Music" scheme="http://leonewang.wang/categories/music/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript Notes]]></title>
    <link href="http://leonewang.wang/2015/08/09/javascript-notes/"/>
    <id>http://leonewang.wang/2015/08/09/javascript-notes/</id>
    <published>2015-08-09T12:01:58.000Z</published>
    <updated>2015-08-09T12:01:58.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>笔记修改自<a href="http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000" target="_blank" rel="external">廖雪峰官方网站</a>，从中记录较为重要的、易于遗忘的部分。</p>
</blockquote>
<h2 id="Based_grammer"><a href="#Based_grammer" class="headerlink" title="Based grammer"></a>Based grammer</h2><h3 id="string_methods"><a href="#string_methods" class="headerlink" title="string methods"></a>string methods</h3><p><code>charAt()</code>    返回指定索引位置的字符<br><code>charCodeAt()</code>    返回指定索引位置字符的Unicode值<br><code>concat()</code>    连接两个或多个字符串，返回连接后的字符串<br><code>fromCharCode()</code>    将字符转换为Unicode值<br><code>indexOf()</code>    返回字符串中检索指定字符第一次出现的位置<br><code>lastIndexOf()</code>    返回字符串中检索指定字符最后一次出现的位置<br><code>localeCompare()</code>    用本地特定的顺序来比较两个字符串<br><code>match()</code>    找到一个或多个正则表达式的匹配<br><code>replace()</code>    替换与正则表达式匹配的子串<br><code>search()</code>    检索与正则表达式相匹配的值<br><a id="more"></a><br><code>slice()</code>    提取字符串的片断，并在新的字符串中返回被提取的部分<br><code>split()</code>    把字符串分割为子字符串数组<br><code>substr()</code>    从起始索引号提取字符串中指定数目的字符<br><code>substring()</code>    提取字符串中两个指定的索引号之间的字符<br><code>toLocaleLowerCase()</code>    根据主机的语言环境把字符串转换为小写，只有几种语言（如土耳其语）具有地方特有的大小写映射<br><code>toLocaleUpperCase()</code>    根据主机的语言环境把字符串转换为大写，只有几种语言（如土耳其语）具有地方特有的大小写映射<br><code>toLowerCase()</code>    把字符串转换为小写<br><code>toString()</code>    返回字符串对象值<br><code>toUpperCase()</code>    把字符串转换为大写<br><code>trim()</code>    移除字符串首尾空白<br><code>valueOf()</code>    返回某个字符串对象的原始值</p>
<p>例：字符转换数字</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">string2int</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> s.split(<span class="string">''</span>)</span><br><span class="line">    .map(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x.charCodeAt(<span class="number">0</span>) - <span class="string">'0'</span>.charCodeAt(<span class="number">0</span>)&#125;)</span><br><span class="line">    .reduce(<span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>) </span>&#123; <span class="keyword">return</span> <span class="number">10</span> * x + y&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例：把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalize</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x[<span class="number">0</span>].toUpperCase() + x.slice(<span class="number">1</span>).toLowerCase() &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="push_and_pop"><a href="#push_and_pop" class="headerlink" title="push and pop"></a>push and pop</h3><p>push()向Array的末尾添加若干元素，pop()则把Array的最后一个元素删除掉：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">arr.push(<span class="string">'A'</span>, <span class="string">'B'</span>); <span class="comment">// 返回Array新的长度: 4</span></span><br><span class="line">arr; <span class="comment">// [1, 2, 'A', 'B']</span></span><br><span class="line">arr.pop(); <span class="comment">// pop()返回'B'</span></span><br><span class="line">arr; <span class="comment">// [1, 2, 'A']</span></span><br><span class="line">arr.pop(); arr.pop(); arr.pop(); <span class="comment">// 连续pop 3次</span></span><br><span class="line">arr; <span class="comment">// []</span></span><br><span class="line">arr.pop(); <span class="comment">// 空数组继续pop不会报错，而是返回undefined</span></span><br><span class="line">arr; <span class="comment">// []</span></span><br></pre></td></tr></table></figure>
<h3 id="unshift_and_shift"><a href="#unshift_and_shift" class="headerlink" title="unshift and shift"></a>unshift and shift</h3><p>如果要往Array的头部添加若干元素，使用unshift()方法，shift()方法则把Array的第一个元素删掉：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">arr.unshift(<span class="string">'A'</span>, <span class="string">'B'</span>); <span class="comment">// 返回Array新的长度: 4</span></span><br><span class="line">arr; <span class="comment">// ['A', 'B', 1, 2]</span></span><br><span class="line">arr.shift(); <span class="comment">// 'A'</span></span><br><span class="line">arr; <span class="comment">// ['B', 1, 2]</span></span><br><span class="line">arr.shift(); arr.shift(); arr.shift(); <span class="comment">// 连续shift 3次</span></span><br><span class="line">arr; <span class="comment">// []</span></span><br><span class="line">arr.shift(); <span class="comment">// 空数组继续shift不会报错，而是返回undefined</span></span><br><span class="line">arr; <span class="comment">// []</span></span><br></pre></td></tr></table></figure>
<h3 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h3><p>splice() 方法是修改Array的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'Microsoft'</span>, <span class="string">'Apple'</span>, <span class="string">'Yahoo'</span>, <span class="string">'AOL'</span>, <span class="string">'Excite'</span>, <span class="string">'Oracle'</span>];</span><br><span class="line"><span class="comment">// 从索引2开始删除3个元素,然后再添加两个元素:</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">3</span>, <span class="string">'Google'</span>, <span class="string">'Facebook'</span>); <span class="comment">// 返回删除的元素 ['Yahoo', 'AOL', 'Excite']</span></span><br><span class="line">arr; <span class="comment">// ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']</span></span><br><span class="line"><span class="comment">// 只删除,不添加:</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// ['Google', 'Facebook']</span></span><br><span class="line">arr; <span class="comment">// ['Microsoft', 'Apple', 'Oracle']</span></span><br><span class="line"><span class="comment">// 只添加,不删除:</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">0</span>, <span class="string">'Google'</span>, <span class="string">'Facebook'</span>); <span class="comment">// 返回[],因为没有删除任何元素</span></span><br><span class="line">arr; <span class="comment">// ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']</span></span><br></pre></td></tr></table></figure>
<h3 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h3><p>concat()方法把当前的Array和另一个Array连接起来，并返回一个新的Array：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</span><br><span class="line"><span class="keyword">var</span> added = arr.concat([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">added; <span class="comment">// ['A', 'B', 'C', 1, 2, 3]</span></span><br><span class="line">arr; <span class="comment">// ['A', 'B', 'C']</span></span><br></pre></td></tr></table></figure>
<p>请注意，concat()方法并没有修改当前Array，而是返回了一个新的Array。</p>
<p>实际上，concat()方法可以接收任意个元素和Array，并且自动把Array拆开，然后全部添加到新的Array里：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</span><br><span class="line">arr.concat(<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]); <span class="comment">// ['A', 'B', 'C', 1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>
<h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p>join()方法是一个非常实用的方法，它把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.join(<span class="string">'-'</span>); <span class="comment">// 'A-B-C-1-2-3'</span></span><br></pre></td></tr></table></figure>
<p>如果Array的元素不是字符串，将自动转换为字符串后再连接。</p>
<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p>由于JavaScript的对象是动态类型，你可以自由地给一个对象添加或删除属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span></span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.age; <span class="comment">// undefined</span></span><br><span class="line">xiaoming.age = <span class="number">18</span>; <span class="comment">// 新增一个age属性</span></span><br><span class="line">xiaoming.age; <span class="comment">// 18</span></span><br><span class="line"><span class="keyword">delete</span> xiaoming.age; <span class="comment">// 删除age属性</span></span><br></pre></td></tr></table></figure>
<p>如果我们要检测xiaoming是否拥有某一属性，可以用in操作符：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    school: <span class="string">'No.1 Middle School'</span>,</span><br><span class="line">    height: <span class="number">1.70</span>,</span><br><span class="line">    weight: <span class="number">65</span>,</span><br><span class="line">    score: <span class="literal">null</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="string">'name'</span> <span class="keyword">in</span> xiaoming; <span class="comment">// true</span></span><br><span class="line"><span class="string">'grade'</span> <span class="keyword">in</span> xiaoming; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>不过要小心，如果in判断一个属性存在，这个属性不一定是xiaoming的，它可能是xiaoming继承得到的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'toString'</span> <span class="keyword">in</span> xiaoming; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>因为toString定义在object对象中，而所有对象最终都会在原型链上指向object，所以xiaoming也拥有toString属性。</p>
<p>要判断一个属性是否是xiaoming自身拥有的，而不是继承得到的，可以用hasOwnProperty()方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span></span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.hasOwnProperty(<span class="string">'name'</span>); <span class="comment">// true</span></span><br><span class="line">xiaoming.hasOwnProperty(<span class="string">'toString'</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>JavaScript的默认对象表示方式{}可以视为其他语言中的Map或Dictionary的数据结构，即一组键值对。</p>
<p>但是JavaScript的对象有个小问题，就是键必须是字符串。但实际上Number或者其他数据类型作为键也是非常合理的。</p>
<p>为了解决这个问题，最新的ES6规范引入了新的数据类型Map。</p>
<p>Map是一组键值对的结构，具有极快的查找速度。</p>
<p>初始化Map需要一个二维数组，或者直接初始化一个空Map。Map具有以下方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>(); <span class="comment">// 空Map</span></span><br><span class="line">m.set(<span class="string">'Adam'</span>, <span class="number">67</span>); <span class="comment">// 添加新的key-value</span></span><br><span class="line">m.set(<span class="string">'Bob'</span>, <span class="number">59</span>);</span><br><span class="line">m.has(<span class="string">'Adam'</span>); <span class="comment">// 是否存在key 'Adam': true</span></span><br><span class="line">m.get(<span class="string">'Adam'</span>); <span class="comment">// 67</span></span><br><span class="line">m.delete(<span class="string">'Adam'</span>); <span class="comment">// 删除key 'Adam'</span></span><br><span class="line">m.get(<span class="string">'Adam'</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">m.set(<span class="string">'Adam'</span>, <span class="number">67</span>);</span><br><span class="line">m.set(<span class="string">'Adam'</span>, <span class="number">88</span>);</span><br><span class="line">m.get(<span class="string">'Adam'</span>); <span class="comment">// 88</span></span><br></pre></td></tr></table></figure>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key。</p>
<p>要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="built_in">Set</span>(); <span class="comment">// 空Set</span></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// 含1, 2, 3</span></span><br></pre></td></tr></table></figure>
<p>重复元素在Set中自动被过滤：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="string">'3'</span>]);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2, 3, "3"&#125;</span></span><br></pre></td></tr></table></figure>
<p>通过<code>add(key)</code>方法可以添加到Set中，通过<code>delete(key)</code>方法可以删除元素。</p>
<h2 id="iterable"><a href="#iterable" class="headerlink" title="iterable"></a>iterable</h2><p>你可能会有疑问，for … of循环和for … in循环有何区别？</p>
<p>for … in循环由于历史遗留问题，它遍历的实际上是对象的属性名称。一个Array数组实际上也是一个对象，它的每个元素的索引被视为一个属性。</p>
<p>当我们手动给Array对象添加了额外的属性后，for … in循环将带来意想不到的意外效果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</span><br><span class="line">a.name = <span class="string">'Hello'</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">in</span> a) &#123;</span><br><span class="line">    alert(x); <span class="comment">// '0', '1', '2', 'name'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>for … in循环将把name包括在内，但Array的length属性却不包括在内。<br>for … of循环则完全修复了这些问题，它只循环集合本身的元素：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</span><br><span class="line">a.name = <span class="string">'Hello'</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> a) &#123;</span><br><span class="line">    alert(x); <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是为什么要引入新的for … of循环。</p>
<p>然而，更好的方式是直接使用iterable内置的forEach方法，它接收一个函数，每次迭代就自动回调该函数。以Array为例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</span><br><span class="line">a.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">element, index, array</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// element: 指向当前元素的值</span></span><br><span class="line">    <span class="comment">// index: 指向当前索引</span></span><br><span class="line">    <span class="comment">// array: 指向Array对象本身</span></span><br><span class="line">    alert(element);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Set与Array类似，但Set没有索引，因此回调函数最多两个参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]);</span><br><span class="line">s.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">element, set</span>) </span>&#123;</span><br><span class="line">    alert(element);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Map的回调函数参数依次为value、key和map本身：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">'x'</span>], [<span class="number">2</span>, <span class="string">'y'</span>], [<span class="number">3</span>, <span class="string">'z'</span>]]);</span><br><span class="line">m.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">value, key, map</span>) </span>&#123;</span><br><span class="line">    alert(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><h3 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h3><p>JavaScript还有一个免费赠送的关键字arguments，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。arguments类似Array但它不是一个Array：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    alert(x); <span class="comment">// 10</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">        alert(<span class="built_in">arguments</span>[i]); <span class="comment">// 10, 20, 30</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure>
<h3 id="rest"><a href="#rest" class="headerlink" title="rest"></a>rest</h3><p>ES6标准引入了rest参数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b, ...rest</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a = '</span> + a);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'b = '</span> + b);</span><br><span class="line">    <span class="built_in">console</span>.log(rest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// 结果:</span></span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = 2</span></span><br><span class="line"><span class="comment">// Array [ 3, 4, 5 ]</span></span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 结果:</span></span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = undefined</span></span><br><span class="line"><span class="comment">// Array []</span></span><br></pre></td></tr></table></figure>
<p>rest参数只能写在最后，前面用<code>...</code>标识，从运行结果可知，传入的参数先绑定a、b，多余的参数以数组形式交给变量rest，所以，不再需要arguments我们就获取了全部参数。</p>
<p>如果传入的参数连正常定义的参数都没填满，也不要紧，rest参数会接收一个空数组（注意不是undefined）。</p>
<h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><p>要指定函数的this指向哪个对象，可以用函数本身的apply方法，它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。</p>
<p>apply 还有更为有用的使用方式<strong>装饰器</strong></p>
<p>利用apply()，我们还可以动态改变函数的行为。</p>
<p>JavaScript的所有对象都是动态的，即使内置的函数，我们也可以重新指向新的函数。</p>
<p>现在假定我们想统计一下代码一共调用了多少次parseInt()，可以把所有的调用都找出来，然后手动加上count += 1，不过这样做太傻了。最佳方案是用我们自己的函数替换掉默认的parseInt()：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> oldParseInt = <span class="built_in">parseInt</span>; <span class="comment">// 保存原函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.parseInt = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    count += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> oldParseInt.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>); <span class="comment">// 调用原函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试:</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'10'</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'20'</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'30'</span>);</span><br><span class="line">count; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>另一个与apply()类似的方法是call()，唯一区别是：</p>
<p>apply()把参数打包成Array再传入；</p>
<p>call()把参数按顺序传入。</p>
<p>比如调用Math.max(3, 5, 4)，分别用apply()和call()实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, [<span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>]); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">Math</span>.max.call(<span class="literal">null</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p>对普通函数调用，我们通常把this绑定为null。</p>
<h2 id="Higher-order_function"><a href="#Higher-order_function" class="headerlink" title="Higher-order function"></a>Higher-order function</h2><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>举例说明，比如我们有一个函数f(x)=x2，要把这个函数作用在一个数组[1, 2, 3, 4, 5, 6, 7, 8, 9]上，就可以用map实现如下：</p>
<p>由于map()方法定义在JavaScript的Array中，我们调用Array的map()方法，传入我们自己的函数，就得到了一个新的Array作为结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pow</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line">arr.map(pow); <span class="comment">// [1, 4, 9, 16, 25, 36, 49, 64, 81]</span></span><br></pre></td></tr></table></figure>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p>reduce 的用法</p>
<p>Array 的 reduce() 方法中的函数必须接受两个参数， reduce() 将结果继续和序列中的下一个元素做累积运算。</p>
<p>比方说对一个 Array 进行求和：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>];</span><br><span class="line">arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>filter也是一个常用的操作，它用于把Array的某些元素过滤掉，然后返回剩下的元素。</p>
<p>和map()类似，Array的filter()也接收一个函数。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素。</p>
<p>例如，在一个Array中，删掉偶数，只保留奇数，可以这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line">arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">2</span> === <span class="number">1</span>;</span><br><span class="line">&#125;); <span class="comment">// [1, 5, 9, 15]</span></span><br></pre></td></tr></table></figure>
<p>请尝试用filter()筛选出素数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_primes</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">1</span>) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">2</span>; i &lt;= <span class="built_in">Math</span>.sqrt(x); i ++ ) &#123;</span><br><span class="line">             <span class="keyword">if</span>(x % i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'Google'</span>, <span class="string">'apple'</span>, <span class="string">'Microsoft'</span>];</span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span> (<span class="params">s1, s2</span>) </span>&#123;</span><br><span class="line">    x1 = s1.toUpperCase();</span><br><span class="line">    x2 = s2.toUpperCase();</span><br><span class="line">    <span class="keyword">if</span> (x1 &lt; x2) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x1 &gt;; x2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;); <span class="comment">// ['apple', 'Google', 'Microsoft']</span></span><br></pre></td></tr></table></figure>
<h2 id="Closure"><a href="#Closure" class="headerlink" title="Closure"></a>Closure</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lazy_sum</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们调用lazy_sum()时，返回的并不是求和结果，而是求和函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = lazy_sum([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]); <span class="comment">// function sum()</span></span><br></pre></td></tr></table></figure>
<p>调用函数f时，才真正计算求和的结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们在函数<code>lazy_sum</code>中又定义了函数<code>sum</code>，并且，内部函数sum可以引用外部函数<code>lazy_sum</code>的参数和局部变量，当<code>lazy_sum</code>返回函数<code>sum</code>时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。</p>
<p>闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起来。</p>
<p>闭包还可以把多参数的函数变成单参数的函数。例如，要计算xy可以用<code>Math.pow(x, y)</code>函数，不过考虑到经常计算x^2或x^3，我们可以利用闭包创建新的函数pow2和pow3：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">make_pow</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.pow(x, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建两个新函数:</span></span><br><span class="line"><span class="keyword">var</span> pow2 = make_pow(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> pow3 = make_pow(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">pow2(<span class="number">5</span>); <span class="comment">// 25</span></span><br><span class="line">pow3(<span class="number">7</span>); <span class="comment">// 343</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>需加强对闭包的理解</p>
</blockquote>
<h2 id="u6807_u51C6_u5BF9_u8C61"><a href="#u6807_u51C6_u5BF9_u8C61" class="headerlink" title="标准对象"></a>标准对象</h2><p>特别注意<code>null</code>的类型是<code>object</code>，<code>Array</code>的类型也是<code>object</code>，如果我们用<code>typeof</code>将无法区分出<code>null</code>、<code>Array</code>和通常意义上的object——<code>{}</code></p>
<p>总结一下，有这么几条规则需要遵守：</p>
<ul>
<li>不要使用new Number()、new Boolean()、new String()创建包装对象；</li>
<li>用parseInt()或parseFloat()来转换任意类型到number</li>
<li>用String()来转换任意类型到string，或者直接调用某个对象的toString()方法；</li>
<li>通常不必把任意类型转换为boolean再判断，因为可以直接写if (myVar) {…}；</li>
<li>typeof操作符可以判断出number、boolean、string、function和undefined；</li>
<li>判断Array要使用Array.isArray(arr)；</li>
<li>判断null请使用myVar === null；</li>
<li>判断某个全局变量是否存在用typeof window.myVar === ‘undefined’；</li>
<li>函数内部判断某个变量是否存在用typeof myVar === ‘undefined’。</li>
</ul>
<p>最后有细心的同学指出，任何对象都有toString()方法吗？null和undefined就没有！确实如此，这两个特殊值要除外，虽然null还伪装成了object类型。</p>
<p>更细心的同学指出，number对象调用toString()报SyntaxError：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123.</span>toString(); <span class="comment">// SyntaxError</span></span><br></pre></td></tr></table></figure>
<p>遇到这种情况，要特殊处理一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123.</span>.toString(); <span class="comment">// '123', 注意是两个点！</span></span><br><span class="line">(<span class="number">123</span>).toString(); <span class="comment">// '123'</span></span><br></pre></td></tr></table></figure>
<p>因为JavaScript中只有一种数字类型：基于IEEE 754标准的双精度。它并没有为整数给出一种特定的类型。所以所有的数字都是小数。<code>123.toString()</code>等价于<code>123.0toString()</code>，除非使用<code>(123).toString()</code>，<code>(123).toString()</code>等价于<code>123.0.toString()</code> 和 <code>123..toString()</code>。<br>因为 <code>123\. === 123.0 //true</code>。</p>
<h2 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a>RegExp</h2><h3 id="u8D2A_u5A6A_u5339_u914D"><a href="#u8D2A_u5A6A_u5339_u914D" class="headerlink" title="贪婪匹配"></a>贪婪匹配</h3><p>需要特别指出的是，正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的0：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^(\d+)(0*)$/</span>;</span><br><span class="line">re.exec(<span class="string">'102300'</span>); <span class="comment">// ['102300', '102300', '']</span></span><br></pre></td></tr></table></figure>
<p>由于\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符串了。</p>
<p>必须让\d+采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，加个?就可以让\d+采用非贪婪匹配：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^(\d+?)(0*)$/</span>;</span><br><span class="line">re.exec(<span class="string">'102300'</span>); <span class="comment">// ['102300', '1023', '00']</span></span><br></pre></td></tr></table></figure>
<p>全局搜索</p>
<p>JavaScript的正则表达式还有几个特殊的标志，最常用的是g，表示全局匹配：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r1 = <span class="regexp">/test/g</span>;</span><br><span class="line"><span class="comment">// 等价于:</span></span><br><span class="line"><span class="keyword">var</span> r2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'test'</span>, <span class="string">'g'</span>);</span><br></pre></td></tr></table></figure>
<p>全局匹配可以多次执行exec()方法来搜索一个匹配的字符串。当我们指定g标志后，每次运行exec()，正则表达式本身会更新lastIndex属性，表示上次匹配到的最后索引：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'JavaScript, VBScript, JScript and ECMAScript'</span>;</span><br><span class="line"><span class="keyword">var</span> re=<span class="regexp">/[a-zA-Z]+Script/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用全局匹配:</span></span><br><span class="line">re.exec(s); <span class="comment">// ['JavaScript']</span></span><br><span class="line">re.lastIndex; <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">re.exec(s); <span class="comment">// ['VBScript']</span></span><br><span class="line">re.lastIndex; <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">re.exec(s); <span class="comment">// ['JScript']</span></span><br><span class="line">re.lastIndex; <span class="comment">// 29</span></span><br><span class="line"></span><br><span class="line">re.exec(s); <span class="comment">// ['ECMAScript']</span></span><br><span class="line">re.lastIndex; <span class="comment">// 44</span></span><br><span class="line"></span><br><span class="line">re.exec(s); <span class="comment">// null，直到结束仍没有匹配到</span></span><br></pre></td></tr></table></figure>
<p>全局匹配类似搜索，因此不能使用/^…$/，那样只会最多匹配一次。</p>
<p>正则表达式还可以指定i标志，表示忽略大小写，m标志，表示执行多行匹配。</p>
<h2 id="Browser"><a href="#Browser" class="headerlink" title="Browser"></a>Browser</h2><h3 id="insertBefore"><a href="#insertBefore" class="headerlink" title="insertBefore"></a>insertBefore</h3><p>如果我们要把子节点插入到指定的位置怎么办？可以使用parentElement.insertBefore(newElement, referenceElement);，子节点会插入到referenceElement之前。</p>
<p>假定我们要把Haskell插入到Python之前：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML结构 --&gt;</span>;</span><br><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"list"</span>&gt;</span>;</span><br><span class="line">    <span class="tag">&lt;<span class="title">p</span> <span class="attribute">id</span>=<span class="value">"java"</span>&gt;</span>;Java<span class="tag">&lt;/<span class="title">p</span>&gt;</span>;</span><br><span class="line">    <span class="tag">&lt;<span class="title">p</span> <span class="attribute">id</span>=<span class="value">"python"</span>&gt;</span>;Python<span class="tag">&lt;/<span class="title">p</span>&gt;</span>;</span><br><span class="line">    <span class="tag">&lt;<span class="title">p</span> <span class="attribute">id</span>=<span class="value">"scheme"</span>&gt;</span>;Scheme<span class="tag">&lt;/<span class="title">p</span>&gt;</span>;</span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span>;</span><br></pre></td></tr></table></figure>
<p>可以这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="built_in">document</span>.getElementById(<span class="string">'list'</span>),</span><br><span class="line">    ref = <span class="built_in">document</span>.getElementById(<span class="string">'python'</span>),</span><br><span class="line">    haskell = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</span><br><span class="line">haskell.id = <span class="string">'haskell'</span>;</span><br><span class="line">haskell.innerText = <span class="string">'Haskell'</span>;</span><br><span class="line">list.insertBefore(haskell, ref);</span><br></pre></td></tr></table></figure>
<h2 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h2><h3 id="24_u7B26_u53F7"><a href="#24_u7B26_u53F7" class="headerlink" title="$符号"></a>$符号</h3><p><code>$</code>是著名的jQuery符号。实际上，jQuery把所有功能全部封装在一个全局变量jQuery中，而$也是一个合法的变量名，它是变量jQuery的别名：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.jQuery; <span class="comment">// jQuery(selector, context)</span></span><br><span class="line"><span class="built_in">window</span>.$; <span class="comment">// jQuery(selector, context)</span></span><br><span class="line">$ === jQuery; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span>($); <span class="comment">// 'function'</span></span><br></pre></td></tr></table></figure>
<p><code>$</code>本质上就是一个函数，但是函数也是对象，于是$除了可以直接调用外，也可以有很多其他属性。</p>
<p>注意，你看到的<code>$</code>函数名可能不是<code>jQuery(selector, context)</code>，因为很多JavaScript压缩工具可以对函数名和参数改名，所以压缩过的jQuery源码<code>$</code>函数可能变成<code>a(b, c)</code>。</p>
<p>绝大多数时候，我们都直接用<code>$</code>（因为写起来更简单嘛）。但是，如果<code>$</code>这个变量不幸地被占用了，而且还不能改，那我们就只能让<code>jQuery</code>把<code>$</code>变量交出来，然后就只能使用jQuery这个变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$; <span class="comment">// jQuery(selector, context)</span></span><br><span class="line">jQuery.noConflict();</span><br><span class="line">$; <span class="comment">// undefined</span></span><br><span class="line">jQuery; <span class="comment">// jQuery(selector, context)</span></span><br></pre></td></tr></table></figure>
<p>这种黑魔法的原理是jQuery在占用<code>$</code>之前，先在内部保存了原来的<code>$</code>,调用<code>jQuery.noConflict()</code>时会把原来保存的变量还原。</p>
<h3 id="u67E5_u627E_u548C_u8FC7_u6EE4"><a href="#u67E5_u627E_u548C_u8FC7_u6EE4" class="headerlink" title="查找和过滤"></a>查找和过滤</h3><p>map()方法把一个jQuery对象包含的若干DOM节点转化为其他对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> langs = $(<span class="string">'ul.lang li'</span>); <span class="comment">// 拿到JavaScript, Python, Swift, Scheme和Haskell</span></span><br><span class="line"><span class="keyword">var</span> arr = langs.map(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.innerHTML;</span><br><span class="line">&#125;).get(); <span class="comment">// 用get()拿到包含string的Array：['JavaScript', 'Python', 'Swift', 'Scheme', 'Haskell']</span></span><br></pre></td></tr></table></figure>
<h3 id="u7EC3_u4E60"><a href="#u7EC3_u4E60" class="headerlink" title="练习"></a>练习</h3><p>对如下的Form表单：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">form</span> <span class="attribute">id</span>=<span class="value">"test-form"</span> <span class="attribute">action</span>=<span class="value">"test"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">legend</span>&gt;</span>请选择想要学习的编程语言：<span class="tag">&lt;/<span class="title">legend</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">fieldset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">label</span> <span class="attribute">class</span>=<span class="value">"selectAll"</span>&gt;</span><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"checkbox"</span>&gt;</span> <span class="tag">&lt;<span class="title">span</span> <span class="attribute">class</span>=<span class="value">"selectAll"</span>&gt;</span>全选<span class="tag">&lt;/<span class="title">span</span>&gt;</span><span class="tag">&lt;<span class="title">span</span> <span class="attribute">class</span>=<span class="value">"deselectAll"</span>&gt;</span>全不选<span class="tag">&lt;/<span class="title">span</span>&gt;</span><span class="tag">&lt;/<span class="title">label</span>&gt;</span> [反选](#0)</span><br><span class="line">        <span class="tag">&lt;<span class="title">label</span>&gt;</span><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"checkbox"</span> <span class="attribute">name</span>=<span class="value">"lang"</span> <span class="attribute">value</span>=<span class="value">"javascript"</span>&gt;</span> JavaScript<span class="tag">&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">label</span>&gt;</span><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"checkbox"</span> <span class="attribute">name</span>=<span class="value">"lang"</span> <span class="attribute">value</span>=<span class="value">"python"</span>&gt;</span> Python<span class="tag">&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">label</span>&gt;</span><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"checkbox"</span> <span class="attribute">name</span>=<span class="value">"lang"</span> <span class="attribute">value</span>=<span class="value">"ruby"</span>&gt;</span> Ruby<span class="tag">&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">label</span>&gt;</span><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"checkbox"</span> <span class="attribute">name</span>=<span class="value">"lang"</span> <span class="attribute">value</span>=<span class="value">"haskell"</span>&gt;</span> Haskell<span class="tag">&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">label</span>&gt;</span><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"checkbox"</span> <span class="attribute">name</span>=<span class="value">"lang"</span> <span class="attribute">value</span>=<span class="value">"scheme"</span>&gt;</span> Scheme<span class="tag">&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">button</span> <span class="attribute">type</span>=<span class="value">"submit"</span>&gt;</span>Submit<span class="tag">&lt;/<span class="title">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">fieldset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>绑定合适的事件处理函数，实现以下逻辑：</p>
<ul>
<li>当用户勾上“全选”时，自动选中所有语言，并把“全选”变成“全不选”；<p></p></li>
<li>当用户去掉“全不选”时，自动不选中所有语言；</li>
<li>当用户点击“反选”时，自动把所有语言状态反转（选中的变为未选，未选的变为选中）；</li>
<li>当用户把所有语言都手动勾上时，“全选”被自动勾上，并变为“全不选”；</li>
<li>当用户手动去掉选中至少一种语言时，“全不选”自动被去掉选中，并变为“全选”。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    form = $(<span class="string">'#test-form'</span>),</span><br><span class="line">    langs = form.find(<span class="string">'[name=lang]'</span>),</span><br><span class="line">    selectAll = form.find(<span class="string">'label.selectAll :checkbox'</span>),</span><br><span class="line">    selectAllLabel = form.find(<span class="string">'label.selectAll span.selectAll'</span>),</span><br><span class="line">    deselectAllLabel = form.find(<span class="string">'label.selectAll span.deselectAll'</span>),</span><br><span class="line">    invertSelect = form.find(<span class="string">'a.invertSelect'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置初始化状态:</span></span><br><span class="line">form.find(<span class="string">'*'</span>).show().off();</span><br><span class="line">form.find(<span class="string">':checkbox'</span>).prop(<span class="string">'checked'</span>, <span class="literal">false</span>).off();</span><br><span class="line">deselectAllLabel.hide();</span><br><span class="line"><span class="comment">// 拦截form提交事件:</span></span><br><span class="line">form.off().submit(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    alert(form.serialize());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">selectAll.click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    langs.prop(<span class="string">'checked'</span>,<span class="keyword">this</span>.checked);</span><br><span class="line">    selectAllLabel.toggle(!<span class="keyword">this</span>.checked);</span><br><span class="line">    deselectAllLabel.toggle(<span class="keyword">this</span>.checked);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">invertSelect.click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    langs.map(<span class="function"><span class="keyword">function</span>(<span class="params">k,v</span>)</span>&#123;</span><br><span class="line">        $(v).prop(<span class="string">'checked'</span>,!v.checked);</span><br><span class="line">    &#125;);</span><br><span class="line">    langs.change();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">langs.change(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">    langs.map(<span class="function"><span class="keyword">function</span>(<span class="params">k,v</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(v.checked) &#123;count++;&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    selectAll.prop(<span class="string">'checked'</span>,count===langs.length);</span><br><span class="line">    selectAllLabel.toggle(!(count===langs.length));</span><br><span class="line">    deselectAllLabel.toggle(count===langs.length);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="jQuery__u63D2_u4EF6"><a href="#jQuery__u63D2_u4EF6" class="headerlink" title="jQuery 插件"></a>jQuery 插件</h3><p></p><p>当我们使用jQuery对象的方法时，由于jQuery对象可以操作一组DOM，而且支持链式操作，所以用起来非常方便。</p>
<p>给jQuery对象绑定一个新方法是通过扩展$.fn对象实现的。让我们来编写第一个扩展——highlight1()：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$.fn.highlight1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// this已绑定为当前jQuery对象:</span></span><br><span class="line">    <span class="keyword">this</span>.css(<span class="string">'backgroundColor'</span>, <span class="string">'#fffceb'</span>).css(<span class="string">'color'</span>, <span class="string">'#d85030'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到函数内部的this在调用时被绑定为jQuery对象，所以函数内部代码可以正常调用所有jQuery对象的方法。</p>
<p>细心的童鞋可能发现了，为什么最后要return this;？因为jQuery对象支持链式操作，我们自己写的扩展方法也要能继续链式下去：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'span.hl'</span>).highlight1().slideDown();</span><br></pre></td></tr></table></figure>
<p>不然，用户调用的时候，就不得不把上面的代码拆成两行。</p>
<p>但是这个版本并不完美。有的用户希望高亮的颜色能自己来指定，怎么办？</p>
<p>我们可以给方法加个参数，让用户自己把参数用对象传进去。于是我们有了第二个版本的highlight2()：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$.fn.highlight2 = <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 要考虑到各种情况:</span></span><br><span class="line">    <span class="comment">// options为undefined</span></span><br><span class="line">    <span class="comment">// options只有部分key</span></span><br><span class="line">    <span class="keyword">var</span> bgcolor = options &amp;amp;&amp;amp; options.backgroundColor || <span class="string">'#fffceb'</span>;</span><br><span class="line">    <span class="keyword">var</span> color = options &amp;amp;&amp;amp; options.color || <span class="string">'#d85030'</span>;</span><br><span class="line">    <span class="keyword">this</span>.css(<span class="string">'backgroundColor'</span>, bgcolor).css(<span class="string">'color'</span>, color);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>紧接着用户对<code>highlight2()</code>提出了意见：每次调用都需要传入自定义的设置，能不能让我自己设定一个缺省值，以后的调用统一使用无参数的<code>highlight2()</code>？</p>
<p>也就是说，我们设定的默认值应该能允许用户修改。</p>
<p>那默认值放哪比较合适？放全局变量肯定不合适，最佳地点是<code>$.fn.highlight2</code>这个函数对象本身。</p>
<p>于是最终版的<code>highlight()</code>终于诞生了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$.fn.highlight = <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 合并默认值和用户设定值:</span></span><br><span class="line">    <span class="keyword">var</span> opts = $.extend(&#123;&#125;, $.fn.highlight.defaults, options);</span><br><span class="line">    <span class="keyword">this</span>.css(<span class="string">'backgroundColor'</span>, opts.backgroundColor).css(<span class="string">'color'</span>, opts.color);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设定默认值:</span></span><br><span class="line">$.fn.highlight.defaults = &#123;</span><br><span class="line">    color: <span class="string">'#d85030'</span>,</span><br><span class="line">    backgroundColor: <span class="string">'#fff8de'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这次用户终于满意了。用户使用时，只需一次性设定默认值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$.fn.highlight.defaults.color = <span class="string">'#fff'</span>;</span><br><span class="line">$.fn.highlight.defaults.backgroundColor = <span class="string">'#000'</span>;</span><br></pre></td></tr></table></figure>
<p>然后就可以非常简单地调用<code>highlight()</code>了。</p>
<p>最终，我们得出编写一个jQuery插件的原则：</p>
<ol>
<li>给<code>$.fn</code>绑定函数，实现插件的代码逻辑；</li>
<li>插件函数最后要<code>return this;</code>以支持链式调用；</li>
<li>插件函数要有默认值，绑定在<code>$.fn.&lt;pluginName&gt;;.defaults</code>上；</li>
<li>用户在调用时可传入设定值以便覆盖默认值。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>笔记修改自<a href="http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000">廖雪峰官方网站</a>，从中记录较为重要的、易于遗忘的部分。</p>
</blockquote>
<h2 id="Based_grammer"><a href="#Based_grammer" class="headerlink" title="Based grammer"></a>Based grammer</h2><h3 id="string_methods"><a href="#string_methods" class="headerlink" title="string methods"></a>string methods</h3><p><code>charAt()</code>    返回指定索引位置的字符<br><code>charCodeAt()</code>    返回指定索引位置字符的Unicode值<br><code>concat()</code>    连接两个或多个字符串，返回连接后的字符串<br><code>fromCharCode()</code>    将字符转换为Unicode值<br><code>indexOf()</code>    返回字符串中检索指定字符第一次出现的位置<br><code>lastIndexOf()</code>    返回字符串中检索指定字符最后一次出现的位置<br><code>localeCompare()</code>    用本地特定的顺序来比较两个字符串<br><code>match()</code>    找到一个或多个正则表达式的匹配<br><code>replace()</code>    替换与正则表达式匹配的子串<br><code>search()</code>    检索与正则表达式相匹配的值<br>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://leonewang.wang/tags/javascript/"/>
    
      <category term="Notes" scheme="http://leonewang.wang/categories/notes/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Question Shredder: Intellij IDEA 14 Tomcat Console Output Messy Code]]></title>
    <link href="http://leonewang.wang/2015/08/04/q-intellij-idea-14/"/>
    <id>http://leonewang.wang/2015/08/04/q-intellij-idea-14/</id>
    <published>2015-08-04T07:04:48.000Z</published>
    <updated>2015-08-04T07:04:48.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Q-description"><a href="#Q-description" class="headerlink" title="Q.description"></a>Q.description</h2><p>Tomcat 7 控制台输出日志乱码</p>
<h2 id="Q-resolvent"><a href="#Q-resolvent" class="headerlink" title="Q.resolvent"></a>Q.resolvent</h2><p>Intellij IDEA 中设置 Web Server 的虚拟机编码，这样 IDE 的编码（控制台编码受IDE影响）和 Web Server 输出的编码一致，问题解决。</p>
<a id="more"></a>
<p><img src="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/08/屏幕快照-2015-08-04-14.59.16-632x252.png" alt="屏幕快照 2015-08-04 14.59.16"></p>
<p>启动 Web Server之后再分析 JVM 的参数可以看到 -Dfile.encoding=UTF-8。</p>
<blockquote>
<p>遇见性更新</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Q-description"><a href="#Q-description" class="headerlink" title="Q.description"></a>Q.description</h2><p>Tomcat 7 控制台输出日志乱码</p>
<h2 id="Q-resolvent"><a href="#Q-resolvent" class="headerlink" title="Q.resolvent"></a>Q.resolvent</h2><p>Intellij IDEA 中设置 Web Server 的虚拟机编码，这样 IDE 的编码（控制台编码受IDE影响）和 Web Server 输出的编码一致，问题解决。</p>]]>
    
    </summary>
    
      <category term="IDE" scheme="http://leonewang.wang/tags/ide/"/>
    
      <category term="Question" scheme="http://leonewang.wang/tags/question/"/>
    
      <category term="Develop" scheme="http://leonewang.wang/categories/develop/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Question Shredder: $(window).height() Problem]]></title>
    <link href="http://leonewang.wang/2015/08/02/q-jquery-window-height-document-height/"/>
    <id>http://leonewang.wang/2015/08/02/q-jquery-window-height-document-height/</id>
    <published>2015-08-02T02:05:33.000Z</published>
    <updated>2015-08-03T07:04:40.000Z</updated>
    <content type="html"><![CDATA[<p>这周遇到的一个小问题，弹出框的显示位置莫名偏下，其位置是由 CSS 的 left 与 top 属性决定，top 的值又根据浏览器视口（viewport）高度和弹出框（popup）的高度计算决定：<code>top = ($(window).height() - popup.height()) / 2;</code></p>
<a id="more"></a>
<p><a href="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/07/屏幕快照-2015-08-02-09.03.30.png" target="_blank" rel="external"><img src="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/07/屏幕快照-2015-08-02-09.03.30-632x404.png" alt="qiestion163 jquery windowWidth = documentWidth d"></a></p>
<p>由于弹出款明显偏低，<strong>猜测视口高度并非真正的视口高度</strong>，于是输出视口高度 $(window).height() 与文档高度 $(document).height() 进行对比。</p>
<p><a href="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/07/屏幕快照-2015-08-02-09.01.21.png" target="_blank" rel="external"><img src="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/07/屏幕快照-2015-08-02-09.01.21-632x315.png" alt="屏幕快照 2015-08-02 09.01.21"></a></p>
<p>结果表明，<strong>页面视口高度与文档高度竟然一致</strong>，即 <code>$(window).height() = $(document).height()</code>。于是乎调试模式开启发现 jsp 解析出得页面中并没有文档声明 <code>&lt;!DOCTYPE html&gt;</code> （我好像知道了点什么），返回代码一查看。如下图，有没有发现什么端倪？</p>
<p><a href="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/07/屏幕快照-2015-07-30-15.02.00.png" target="_blank" rel="external"><img src="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/07/屏幕快照-2015-07-30-15.02.00-632x166.png" alt="屏幕快照 2015-07-30 15.02.00"></a></p>
<p>没错，头部引用了某个 jsp 文件，导致之后的文档声明没有被解析，所以咯，大家以后都要仔细些。将引用放至 head 标签中，问题解决。</p>
<p><a href="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/07/屏幕快照-2015-08-02-09.00.58.png" target="_blank" rel="external"><img src="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/07/屏幕快照-2015-08-02-09.00.58-632x315.png" alt="屏幕快照 2015-08-02 09.00.58"></a><a href="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/07/屏幕快照-2015-08-02-10.05.11.png" target="_blank" rel="external"><img src="http://7xkj8o.com1.z0.glb.clouddn.com/wp-content/uploads/2015/07/屏幕快照-2015-08-02-10.05.11-632x404.png" alt="屏幕快照 2015-08-02 10.05.11"></a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这周遇到的一个小问题，弹出框的显示位置莫名偏下，其位置是由 CSS 的 left 与 top 属性决定，top 的值又根据浏览器视口（viewport）高度和弹出框（popup）的高度计算决定：<code>top = ($(window).height() - popup.height()) / 2;</code></p>]]>
    
    </summary>
    
      <category term="HTML5" scheme="http://leonewang.wang/tags/html5/"/>
    
      <category term="JQuery" scheme="http://leonewang.wang/tags/jquery/"/>
    
      <category term="Question" scheme="http://leonewang.wang/tags/question/"/>
    
      <category term="Develop" scheme="http://leonewang.wang/categories/develop/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Web Design With JavaScript and the DOM]]></title>
    <link href="http://leonewang.wang/2015/07/26/web-design-with-javascript-and-the-dom-dom/"/>
    <id>http://leonewang.wang/2015/07/26/web-design-with-javascript-and-the-dom-dom/</id>
    <published>2015-07-26T13:32:27.000Z</published>
    <updated>2015-07-26T13:32:27.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u6700_u4F73_u5B9E_u8DF5"><a href="#u6700_u4F73_u5B9E_u8DF5" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="u4E0D_u8981_u602A_u7F6A_JavaScript"><a href="#u4E0D_u8981_u602A_u7F6A_JavaScript" class="headerlink" title="不要怪罪 JavaScript"></a>不要怪罪 JavaScript</h3><p>HTML 之所以会呈现爆炸性的增长，HTML 语言易学易用的特点就是其中不可否认的一个原因。很多人花很少的时间就可以掌握 HTML 语言的基本知识，并快速做出各种各样的网页。事实上，也许很多没有写过代码的人们在‘可视化’网页制作工具的帮助下成为了网页设计大军中的一员。</p>
<p>因此产生的不良后果就是，许多网页的编写很糟糕，甚至没有做标记合法性检查，忽略规范，所以浏览器不得不以较为宽松的方式去处理网页。这也使得 CSS，JavaScript 等新技术在 Web 上推广收到了很大的阻力。</p>
<a id="more"></a>
<p>与 HTML 语言相比，Javascript 语言的生存环境要严苛的多，如果 JavaScript 代码不符合语法规范，浏览器将无法执行，而在碰到不符合语法规范的 HTML 代码时，浏览器却又千方百计的把它呈现出来。尽管如此，网络上依旧充斥着许多质量低下的 JavaScript 代码。</p>
<p>许多网页设计者并不舍得花大量的时间来学习 JavaScript，而是把一些现成的代码直接复制到文档中，这依旧得益于‘可视化’的网页设计工具。其实这些现成的 JavaScript 代码里有许多问题考虑的并不周全，从表面上看，似乎这些代码确实帮助我们完成了一些新颖动人的交互效果，但是，他们却很少有能够在禁用 JavaScript 的情况下对网页的行为作出正确地响应。一旦 JavaScript 被禁用，那些质量低劣的代码将在浏览器中得不到很好的解释，甚至完全没法使用。这就让许多人认为 <strong>JavaScript=网页</strong> 无法访问。</p>
<h3 id="u5E73_u7A33_u9000_u5316"><a href="#u5E73_u7A33_u9000_u5316" class="headerlink" title="平稳退化"></a>平稳退化</h3><blockquote>
<p>也许你会说，禁用 JavaScript 的用户已经是少数了，何必耗费大量的时间来优化这些代码呢？</p>
</blockquote>
<p>先说内在因素，请想象一下，有个访问者来到了你的网站，他在浏览 Web 的同时禁用了 JavaScript 和图片，我敢肯定这样的用户现在已近非常少见，但是，这个用户却非常重要，因为他是 —— <strong>Searchbot</strong>（搜索机器人）。其次外在因素，现在的网页的用户体验越来越受到人们的关注，那些不遵循‘用户至上’原则的网站从长远来看都是自取灭亡，况且<code>不追求完美的程序员不是好程序员</code>，你说呢？</p>
<p>如果正确的使用了 JavaScript 脚本，就可以让访问者在禁用了 JavaScript 的情况下仍能继续顺利的浏览你的网站，这就是 <strong>平稳退化</strong> ，就是虽然某些功能无法使用，但最基本的操作仍能顺利完成。</p>
<ul>
<li>分离 javascript</li>
<li>向后兼容（与现代并无必要，大多浏览器足够健壮）</li>
<li>性能考虑<ol>
<li>尽量减少标记和访问 DOM</li>
<li>脚本合并</li>
<li>脚本压缩（工具）<br>A. Douglas Crockford 的 JSMin<br>B. Yahoo 的 YUI Compressor<br>C. Google 的 Closure Compiler</li>
</ol>
</li>
</ul>
<p><em>学习并参考自《DOM Scripting Web Design with JavaScript and the Document Object Model》</em></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u6700_u4F73_u5B9E_u8DF5"><a href="#u6700_u4F73_u5B9E_u8DF5" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="u4E0D_u8981_u602A_u7F6A_JavaScript"><a href="#u4E0D_u8981_u602A_u7F6A_JavaScript" class="headerlink" title="不要怪罪 JavaScript"></a>不要怪罪 JavaScript</h3><p>HTML 之所以会呈现爆炸性的增长，HTML 语言易学易用的特点就是其中不可否认的一个原因。很多人花很少的时间就可以掌握 HTML 语言的基本知识，并快速做出各种各样的网页。事实上，也许很多没有写过代码的人们在‘可视化’网页制作工具的帮助下成为了网页设计大军中的一员。</p>
<p>因此产生的不良后果就是，许多网页的编写很糟糕，甚至没有做标记合法性检查，忽略规范，所以浏览器不得不以较为宽松的方式去处理网页。这也使得 CSS，JavaScript 等新技术在 Web 上推广收到了很大的阻力。</p>]]>
    
    </summary>
    
      <category term="HTML5" scheme="http://leonewang.wang/tags/html5/"/>
    
      <category term="JavaScript" scheme="http://leonewang.wang/tags/javascript/"/>
    
      <category term="Summarize" scheme="http://leonewang.wang/categories/summarize/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Responsive Web Design (Two)]]></title>
    <link href="http://leonewang.wang/2015/07/20/responsive-web-design-two/"/>
    <id>http://leonewang.wang/2015/07/20/responsive-web-design-two/</id>
    <published>2015-07-20T14:36:10.000Z</published>
    <updated>2015-07-20T14:36:10.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u79C1_u6709_u524D_u7F00"><a href="#u79C1_u6709_u524D_u7F00" class="headerlink" title="私有前缀"></a>私有前缀</h2><p>在 CSS3 模块标准尚未被 W3C 批准或者标准所提议的特性尚未被浏览器完全实现时，浏览器厂商会使用所谓的 “私有前缀” 来测试 “试验性” 的 CSS3 特性。开发 CSS3 时，要记住添加相关的浏览器前缀以保证最广泛的浏览器兼容。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.main</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">-ms-border-radius</span>:<span class="value"> <span class="number">10px</span></span></span>;    <span class="comment">/* Microsoft */</span></span><br><span class="line">  <span class="rule"><span class="attribute">-o-border-radius</span>:<span class="value"> <span class="number">10px</span></span></span>;     <span class="comment">/*Opera */</span></span><br><span class="line">  <span class="rule"><span class="attribute">-moz-border-radius</span>:<span class="value"> <span class="number">10px</span></span></span>;   <span class="comment">/* Mozilla (Firefox) */</span></span><br><span class="line">  <span class="rule"><span class="attribute">-webkit-border-radius</span>:<span class="value"> <span class="number">10px</span></span></span>;    <span class="comment">/* Webkit (Safari,Chrome) */</span></span><br><span class="line">  <span class="rule"><span class="attribute">border-radius</span>:<span class="value"> <span class="number">10px</span></span></span>;    <span class="comment">/* W3C 标准 */</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>我知道你在想什么，对同一个属性写多个私有前缀声明是否会造成代码臃肿？确实会有那么一点。但无论追加多少属性，相对于使用图片完成类似效果，这仍然是一个快速、优雅而健壮的解决方案。这里推荐给大家一个相关网站<a href="http://caniuse.com/" target="_blank" rel="external">caniuse.com</a>，在这里可以知道当前浏览器对特定 HTML5 和 CSS3 特性的支持程度（可按特性搜索）。</p>
<a id="more"></a>
<p>当然了，私有前缀实在是太长了，我想没有一个人愿意手工敲上去，所以也有可以为 CSS 文件自动追加私有前缀的 JavaScript 方案，如 <a href="http:" target="_blank" rel="external">-prefix-free</a>，这样在样式表中就可以只写 W3C 规定的标准代码。</p>
<h2 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h2><h4 id="u65B0_u589E_u9009_u62E9_u5668"><a href="#u65B0_u589E_u9009_u62E9_u5668" class="headerlink" title="新增选择器"></a>新增选择器</h4><h6 id="u5B50_u5B57_u7B26_u4E32_u5339_u914D_u5C5E_u6027_u9009_u62E9_u5668"><a href="#u5B50_u5B57_u7B26_u4E32_u5339_u914D_u5C5E_u6027_u9009_u62E9_u5668" class="headerlink" title="子字符串匹配属性选择器"></a>子字符串匹配属性选择器</h6><ol>
<li><p>“匹配开头” 的属性选择器<br>语法 <code>Element [attribute^=&quot;value&quot;]</code><br>例：选择所有 class 属性以 large 开头的图片:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">img</span> <span class="attr_selector">[class^="large"]</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100%</span></span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>“匹配包含内容” 的属性选择器<br>语法 <code>Element [attribute*=&quot;value&quot;]</code><br>例：选择所有 class 属性包含 large 的图片:</p>
</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">img</span> <span class="attr_selector">[class*="large"]</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100%</span></span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>“匹配结尾” 的属性选择器<br>语法 <code>Element [attribute$=&quot;value&quot;]</code><br>例：选择所有 class 属性以 large 结尾的图片:</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">img</span> <span class="attr_selector">[class$="large"]</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100%</span></span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<h6 id="CSS_u7ED3_u6784_u4F2A_u7C7B"><a href="#CSS_u7ED3_u6784_u4F2A_u7C7B" class="headerlink" title="CSS结构伪类"></a>CSS结构伪类</h6><ol>
<li><p><code>:last-child</code> 选择器</p>
<blockquote>
<p>例：<code>li :last-child</code> 用以匹配最后一项列表项。</p>
</blockquote>
</li>
<li><p><code>:nth-child</code> 选择器</p>
<blockquote>
<p>例：<code>li :nth-child(even)</code> 用以匹配偶数项 <code>li</code> 元素（可选参数 even, odd, 自定义）。主要说说自定义，比如 <code>li :nth-child(2n+1)</code> 用以匹配第 1、3、5 … 项列表项。<br><strong>注意：n 从 0 开始</strong></p>
</blockquote>
</li>
<li><p><code>:nth-last-of-type</code> 选择器</p>
<blockquote>
<p>例：<code>li .list :nth-last-of-type(n+2)</code> 表示从第二个匹配元素<code>li</code> 开始，匹配每一个类名为 list 的列表项。</p>
</blockquote>
</li>
<li><p><code>:not</code> 选择器</p>
<blockquote>
<p>例：<code>li :not(.list)</code> 用以匹配类名不是 list 的列表项。</p>
</blockquote>
</li>
</ol>
<h4 id="u52A8_u753B_u8FC7_u6E21_u7684_u5C40_u9650_u6027"><a href="#u52A8_u753B_u8FC7_u6E21_u7684_u5C40_u9650_u6027" class="headerlink" title="动画过渡的局限性"></a>动画过渡的局限性</h4><p>在使用 CSS3 制作动画时，有些属性无法过渡，尽管规范说它应该可以。例如：background-gradient 属性就无法过渡，但理论上所有的 CSS 属性都是可以过渡的。</p>
<h4 id="u5143_u7D20_u900F_u660E"><a href="#u5143_u7D20_u900F_u660E" class="headerlink" title="元素透明"></a>元素透明</h4><p><strong>为什么不使用 opacity？</strong> 这个问题在初学时困扰了我 long long time。原因在于 opacity 设置的透明度会对整个元素产生影响，而使用 RGBA 或 HSLA 则可以仅让部分有透明效果，这样一个元素就可以拥有透明背景，但内部的文字仍不透明。</p>
<h4 id="u7528_HSL__u4EE3_u66FF_RGB_u3001HEX"><a href="#u7528_HSL__u4EE3_u66FF_RGB_u3001HEX" class="headerlink" title="用 HSL 代替 RGB、HEX"></a>用 HSL 代替 RGB、HEX</h4><p><strong>为什么要用 HSL 呢？</strong> 首先要知道 HSL 是由色相（Hue）、饱和度（Saturation）、明度（Lightness）所组成的，而 RGB 是由 R（Red）、G（Green）、B（Blue）所组成。在我们使用颜色标准时，我相信没有几个人能够看到 <code>RGB(12,12,12)</code> 就知道这是什么颜色，但是当看到 <code>HSL(12,12,12)</code>时，我却能知道这大概是什么颜色——介于红色与橘红色之间的颜色。不要太崇拜 <code>&amp;lt;(￣▽￣)&amp;gt;</code> 哇哈哈…你也可以：</p>
<ul>
<li><p><strong>H (Hue)</strong> 分量</p>
<blockquote>
<p>代表的是人眼所能感知的颜色范围，这些颜色分布在一个平面的色相环上，取值范围是0°到360°的圆心角，每个角度可以代表一种颜色。色相值的意义在于，我们可以在不改变光感的情况下，通过旋转色相环来改变颜色。在实际应用中，我们需要记住色相环上的六大主色，用作基本参照：360°/0°红、60°黄、120°绿、180°青、240°蓝、300°洋红，它们在色相环上按照60°圆心角的间隔排列。</p>
</blockquote>
</li>
<li><p><strong>S (Saturation)</strong> 分量</p>
<blockquote>
<p>指的是色彩的饱和度，它用0%至100%的值描述了相同色相、明度下色彩纯度的变化。数值越大，颜色中的灰色越少，颜色越鲜艳，呈现一种从理性(灰度)到感性(纯色)的变化。</p>
</blockquote>
</li>
<li><p><strong>L (lightness)</strong> 分量</p>
<blockquote>
<p>指的是色彩的明度，作用是控制色彩的明暗变化。它同样使用了0%至100%的取值范围。数值越小，色彩越暗，越接近于黑色；数值越大，色彩越亮，越接近于白色。</p>
</blockquote>
</li>
</ul>
<h2 id="u79BB_u7EBF_Web__u5E94_u7528"><a href="#u79BB_u7EBF_Web__u5E94_u7528" class="headerlink" title="离线 Web 应用"></a>离线 Web 应用</h2><p>必须在每一个准备离线使用的页面的 HTML 标签中都追加 <code>manifest = &quot;/offline.manifest&quot;</code> 属性。当然这仅适用于不需要与服务器端打交道的页面，这点我想你应该明白。</p>
<p><em>以上均为学习 Responsive Web Design with HTML5 and CSS3 后的个人总结，如有错误欢迎指出。</em></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u79C1_u6709_u524D_u7F00"><a href="#u79C1_u6709_u524D_u7F00" class="headerlink" title="私有前缀"></a>私有前缀</h2><p>在 CSS3 模块标准尚未被 W3C 批准或者标准所提议的特性尚未被浏览器完全实现时，浏览器厂商会使用所谓的 “私有前缀” 来测试 “试验性” 的 CSS3 特性。开发 CSS3 时，要记住添加相关的浏览器前缀以保证最广泛的浏览器兼容。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.main</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">-ms-border-radius</span>:<span class="value"> <span class="number">10px</span></span></span>;    <span class="comment">/* Microsoft */</span></span><br><span class="line">  <span class="rule"><span class="attribute">-o-border-radius</span>:<span class="value"> <span class="number">10px</span></span></span>;     <span class="comment">/*Opera */</span></span><br><span class="line">  <span class="rule"><span class="attribute">-moz-border-radius</span>:<span class="value"> <span class="number">10px</span></span></span>;   <span class="comment">/* Mozilla (Firefox) */</span></span><br><span class="line">  <span class="rule"><span class="attribute">-webkit-border-radius</span>:<span class="value"> <span class="number">10px</span></span></span>;    <span class="comment">/* Webkit (Safari,Chrome) */</span></span><br><span class="line">  <span class="rule"><span class="attribute">border-radius</span>:<span class="value"> <span class="number">10px</span></span></span>;    <span class="comment">/* W3C 标准 */</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>我知道你在想什么，对同一个属性写多个私有前缀声明是否会造成代码臃肿？确实会有那么一点。但无论追加多少属性，相对于使用图片完成类似效果，这仍然是一个快速、优雅而健壮的解决方案。这里推荐给大家一个相关网站<a href="http://caniuse.com/">caniuse.com</a>，在这里可以知道当前浏览器对特定 HTML5 和 CSS3 特性的支持程度（可按特性搜索）。</p>]]>
    
    </summary>
    
      <category term="CSS3" scheme="http://leonewang.wang/tags/css3/"/>
    
      <category term="HTML5" scheme="http://leonewang.wang/tags/html5/"/>
    
      <category term="Summarize" scheme="http://leonewang.wang/categories/summarize/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Responsive Web Design (One)]]></title>
    <link href="http://leonewang.wang/2015/07/19/responsive-web-design-one/"/>
    <id>http://leonewang.wang/2015/07/19/responsive-web-design-one/</id>
    <published>2015-07-19T08:45:49.000Z</published>
    <updated>2015-07-19T08:45:49.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>来自 <a href="http://gs.statcounter.com/" target="_blank" rel="external">gs.statcounter.com</a> 的统计数据表明产品从 2010 年 7 月到 2011 年 7 月的 12 个月中，全球手机浏览器的使用量中 2.86% 上升至 7.02%。Internet Explorer 6 的使用率则是从 8.76% 下降到 3.42%。i到 2015 年 7 月，Internet Explorer 6、7、8 三个版本加起来也只不过 10% 的使用率。</p>
</blockquote>
<p>越来越多的人使用小屏幕设备上网。这些设备上的浏览器在设计时都考虑到了如何显示好现有网站，手机浏览器会将一个标准网页缩放至与设备可视区域恰好匹配，然后用户在自己需要的内容区域上放大浏览，为了看清楚页面内容，就需要不停的放大、缩小页面，然后为了看到视口外的文字，又要左右拖动，就像我高中时用手机浏览网页一样。<br><a id="more"></a><br>于是 <strong>响应式 Web 设计</strong> 就应运而生，使页面能够根据视口宽度的改变而进行自由缩放，例如，先针对大视口设计（用户大多数情况下使用鼠标），将页面宽度加宽、导航链接设计成简单地文字连接，然后使用媒体查询重写样式，为拇指一族提供更大的点击区域并将页面宽度适当减小。</p>
<h2 id="u4F7F_u7528_u5A92_u4F53_u67E5_u8BE2"><a href="#u4F7F_u7528_u5A92_u4F53_u67E5_u8BE2" class="headerlink" title="使用媒体查询"></a>使用媒体查询</h2><p>创建媒体查询时，最常用的是设备的视口宽度（ width ）和屏幕宽度（ device-width ）。下面列出一些比较好玩的特性。</p>
<ul>
<li>width: 视口宽度</li>
<li>height: 视口高度</li>
<li>device-width: 视口宽度</li>
<li>device-height: 视口高度</li>
<li>orientation: 检测设备处于横向还是纵向</li>
<li>aspect-ratio: 基于视口宽度和高度的宽高比。一个 16:9 比例的显示屏可以这样定义 aspect-ratio: 16/9。</li>
<li>resolution: 检测屏幕或打印机分辨率，如 min-resolution: 300dpi。还可以接受每厘米像素点数的度量值，如 min-resolution: 118dpcm。</li>
<li>grid: 检测输出设备室网格设备还是位图设备。</li>
</ul>
<h2 id="u52A0_u8F7D_u5A92_u4F53_u7684_u6700_u4F73_u65B9_u6CD5"><a href="#u52A0_u8F7D_u5A92_u4F53_u7684_u6700_u4F73_u65B9_u6CD5" class="headerlink" title="加载媒体的最佳方法"></a>加载媒体的最佳方法</h2><p>现代浏览器虽然可以智能地忽略与自身不匹配的样式文件，但它却不一定不下载这些文件。因此，将不同媒体查询的样式保存到独立的文件中没有太大的好处，使用多个独立的文件会增加用于页面渲染的 HTTP 请求的数量，从而导致页面加载变慢。使用如下语法即可在已有样式表中加入媒体查询：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 当视口宽度小于 768px 时，页面的宽度将变为 700px；</span><br><span class="line">@media screen and (max-width: 768px) &#123;</span><br><span class="line">    body &#123;</span><br><span class="line">        width: 700px;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 当视口宽度大于 768px 小于 992px 时，页面宽度将变为 768px；</span><br><span class="line">@media screen and (min-width: 768px) and (max-width: 992px) &#123;</span><br><span class="line">    body &#123;</span><br><span class="line">        width: 768px;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然除了上面的媒体查询外还可以使用 CSS 的 <code>@import</code> 指令在当前样式表中按条件引入其他样式表。例如下面的代码会给视口最大宽度为 768 像素的显示屏设备加载一个名为 mobile.css 的样式表。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">import</span> <span class="function">url</span>(mobile.css) screen and (max-width: <span class="number">768px</span>)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>切记，使用 CSS 的 <code>@import</code> 方法会增加 HTTP 请求（这会影响加载速度），所以请谨慎使用该方法。</p>
</blockquote>
<h2 id="u62E5_u62B1_u6D41_u5F0F_u5E03_u5C40"><a href="#u62E5_u62B1_u6D41_u5F0F_u5E03_u5C40" class="headerlink" title="拥抱流式布局"></a>拥抱流式布局</h2><p>现在来讲讲布局的问题，我们经常需要根据情况对元素宽度、字体大小进行修改，于是乎我们就要对所有的使用了像素点作为单位的属性进行修改，然后便是一项浩大的工程，所以固定布局禁不起未来的考验。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 示例 1 */</span></span><br><span class="line"><span class="tag">body</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">768px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">16px</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"><span class="class">.left</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">450px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">17px</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"><span class="class">.right</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">300px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">15px</span></span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="u767E_u5206_u6BD4_u5E03_u5C40"><a href="#u767E_u5206_u6BD4_u5E03_u5C40" class="headerlink" title="百分比布局"></a>百分比布局</h4><p>首先来看看元素宽度，如果我们需要将整个页面的宽度加宽 100 px，那么就要将页面的其他各个部分也进行宽度上的调整，使用百分比布局能让我们修改宽度来的更高效。记住百分比转换公式一切迎刃而解，貌似你我数学不至于差到这种程度：</p>
<p></p>
<p><div id="wmd-preview-section-212" class="wmd-preview-section preview-content"></div></p>
<p><div class=""></div></p>
<p><div class="MathJax_SVG_Display"><span id="MathJax-Element-1-Frame" class="MathJax_SVG">百分比宽度目标元素宽度上下文元素宽度</span></div><br><br>现在我们就将 <strong>示例 1</strong> 修改为百分比布局:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 示例 2 */</span></span><br><span class="line"><span class="tag">body</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">768px</span></span></span>;   <span class="comment">/* 仅需修改上下文元素宽度即可完成调整 */</span></span><br><span class="line">    <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">16px</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"><span class="class">.left</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">58.59375%</span></span></span>;   <span class="comment">/* 450 ÷ 768 */</span></span><br><span class="line">    <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">17px</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"><span class="class">.right</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">39.0625%</span></span></span>;    <span class="comment">/* 300 ÷ 768 */</span></span><br><span class="line">    <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">15px</span></span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="u7528_em__u66FF_u6362_px"><a href="#u7528_em__u66FF_u6362_px" class="headerlink" title="用 em 替换 px"></a>用 em 替换 px</h4><p>过去的几年里，网页设计师使用 em 代替 px 主要是为了文字缩放。因为老版本的 IE 无法缩放像素单位的字体。不过现代浏览器很久以前就支持缩放以像素为单位的文字了。那用 ex 替换 px 还用什么必要性和优越性吗？有两点毋庸置疑的理由：</p>
<ol>
<li>那些使用了 IE6 的用户也能缩放文字。</li>
<li>可以使设计师和开发人员的生活更加简单。</li>
</ol>
<blockquote>
<p><strong>em</strong> 的实际大小是相对于其上下文的字体大小而言的。如果我们给<code>&lt;body&gt;</code> 标签设置文字大小为 100%，给其他文字都是用相对单位 em，那这些文字都会受 body 上的初始声明的影响。这样做的好处就是，如果在完成了所有的文字排版后，客户又提出将页面文字统一放大一点，我们就可以只修改 body 的文字大小，其他所有的文字大小也会相应变大。<br>在这样的情况下，我们如果采用了相对大小，一切就来的简单得多了，依旧使用万能的公式 <span class=""><span id="MathJax-Element-2-Frame" class="MathJax_SVG">百分比尺寸目标元素尺寸上下文元素尺寸</span></span> 我们只需要修改<code>body</code> 的 <code>font-size</code> 属性即可。将 <strong>示例 2</strong> 字体更改为相对大小，如下：</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 示例 3 */</span></span><br><span class="line"><span class="tag">body</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">768px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">16px</span></span></span>;    <span class="comment">/* 修改此处即可 */</span></span><br><span class="line">&#125;</span></span><br><span class="line"><span class="class">.left</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">58.59375%</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">1.0625em</span></span></span>;    <span class="comment">/* 17 ÷ 16 */</span></span><br><span class="line">&#125;</span></span><br><span class="line"><span class="class">.right</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">39.0625%</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">font-size</span>:<span class="value"> .<span class="number">9375em</span></span></span>; <span class="comment">/* 15 ÷ 16 */</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="u6DFB_u52A0_u54CD_u5E94_u5F0F_u5A92_u4F53"><a href="#u6DFB_u52A0_u54CD_u5E94_u5F0F_u5A92_u4F53" class="headerlink" title="添加响应式媒体"></a>添加响应式媒体</h2><p>对于很多人来说，可能第一次听说 HTML5 是在 Apple 公司拒绝在 iOS 设备上支持 Flash 的时候，Flash 作为浏览器的视频服务插件已经占据了主导地位，而其发热的特性也已经是众所周知了，所以 Apple 并没有使用 Adobe 的专有技术，而是决定依靠 HTML5 来处理富媒体渲染。HTML5 本身在这一领域已经有了长足进步，Apple 公司对 HTML5 的公开支持又极大促进了他的发展，并使其媒体工具在公众中赢得了更广泛的青睐（够了，我再也不要听到风扇的声音！）。</p>
<h4 id="u7528_HTML5__u7684_u65B9_u6CD5_u4E3A_u9875_u9762_u6DFB_u52A0_u89C6_u9891"><a href="#u7528_HTML5__u7684_u65B9_u6CD5_u4E3A_u9875_u9762_u6DFB_u52A0_u89C6_u9891" class="headerlink" title="用 HTML5 的方法为页面添加视频"></a>用 HTML5 的方法为页面添加视频</h4><p>看到下面的一行代码，你我会心一笑，简直就像是插入了一张图片，不说了，我要偷着乐会儿。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">video</span> <span class="attribute">src</span>=<span class="value">"myVideo.ogg"</span>&gt;</span><span class="tag">&lt;/<span class="title">video</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="u63D0_u4F9B_u5907_u7528_u7684_u5A92_u4F53_u6E90_u6587_u4EF6"><a href="#u63D0_u4F9B_u5907_u7528_u7684_u5A92_u4F53_u6E90_u6587_u4EF6" class="headerlink" title="提供备用的媒体源文件"></a>提供备用的媒体源文件</h4><p>果然我还是太年轻，请把刀给我。最初的 HTML5 规范呼吁所有浏览器内置支持使用 Ogg 格式直接播放视频或音频，但是由于 HTML5 工作组的内部争议，曾经作为基线标准的支持 Ogg 的主张在最近的更新的 HTML5 规范中被放弃。因此，目前一些浏览器支持某一套视频和音频的文件格，而另一些浏览器则支持其他格式。例如，Safari 只允许使用 MP4/H.264/AAC 媒体文件，而 Firefox 和 Opera 则只支持 Ogg 和 WebM。</p>
<p>不过好在有一种方法能够在一个标签内支持多种媒体类型：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">video</span> <span class="attribute">width</span>=<span class="value">"640"</span> <span class="attribute">height</span>=<span class="value">"480"</span> <span class="attribute">controls</span> <span class="attribute">autoplay</span> <span class="attribute">preload</span>=<span class="value">"auto"</span> <span class="attribute">loop</span> <span class="attribute">poster</span>=<span class="value">"myVideoPoster.jpg"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">source</span> <span class="attribute">src</span>=<span class="value">"myVideo.ogg"</span> <span class="attribute">type</span>=<span class="value">"video/ogg"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">source</span> <span class="attribute">src</span>=<span class="value">"myVideo.mp4"</span> <span class="attribute">type</span>=<span class="value">"video/mp4"</span>&gt;</span></span><br><span class="line">    Oops, you need a new browser</span><br><span class="line"><span class="tag">&lt;/<span class="title">video</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果浏览器支持 Ogg 格式，则使用第一个文件，否则它会继续往下解析下一个<code>&lt;source&gt;</code> 标签。</p>
<h4 id="u54CD_u5E94_u5F0F_u89C6_u9891"><a href="#u54CD_u5E94_u5F0F_u89C6_u9891" class="headerlink" title="响应式视频"></a>响应式视频</h4><p>对于 HTML5 式嵌入视频，修正方法很简单，删除视频标签中的 height 和 width 属性，然后再 CSS 中追加：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">video</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">max-width</span>:<span class="value"> <span class="number">100%</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">height</span>:<span class="value"> auto</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>但是有时候我们会想要嵌入 Youtube 的视频，而 HTML5 并不能解决嵌入 iframe 视频的响应问题，最简单的方法是用一个 jQuery 小插件：<a href="http://fitvidsjs.com/" target="_blank" rel="external">FitVids</a>。</p>
<p><em>以上均为学习 Responsive Web Design with HTML5 and CSS3 后的个人总结，如有错误欢迎指出。</em></p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>来自 <a href="http://gs.statcounter.com/">gs.statcounter.com</a> 的统计数据表明产品从 2010 年 7 月到 2011 年 7 月的 12 个月中，全球手机浏览器的使用量中 2.86% 上升至 7.02%。Internet Explorer 6 的使用率则是从 8.76% 下降到 3.42%。i到 2015 年 7 月，Internet Explorer 6、7、8 三个版本加起来也只不过 10% 的使用率。</p>
</blockquote>
<p>越来越多的人使用小屏幕设备上网。这些设备上的浏览器在设计时都考虑到了如何显示好现有网站，手机浏览器会将一个标准网页缩放至与设备可视区域恰好匹配，然后用户在自己需要的内容区域上放大浏览，为了看清楚页面内容，就需要不停的放大、缩小页面，然后为了看到视口外的文字，又要左右拖动，就像我高中时用手机浏览网页一样。<br>]]>
    
    </summary>
    
      <category term="CSS3" scheme="http://leonewang.wang/tags/css3/"/>
    
      <category term="HTML5" scheme="http://leonewang.wang/tags/html5/"/>
    
      <category term="Summarize" scheme="http://leonewang.wang/categories/summarize/"/>
    
  </entry>
  
</feed>
