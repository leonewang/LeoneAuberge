<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> AngularJS Notes · Leone Auberge</title><meta name="description" content="AngularJS Notes - LeoneWang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://leone.wang/atom.xml" title="Leone Auberge"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/share" target="_self" class="nav-list-link">SHARE</a></li><li class="nav-list-item"><a href="https://github.com/leonewang" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">AngularJS Notes</h1><div class="post-info">Jan 18, 2016</div><div class="post-content"><blockquote>
<p>REF:<br><a href="http://baike.baidu.com/link?url=SlAzoxj6IVBVqvcoKI6EExxuU1a4yXzW9CiSMFdN9azJXxovxoD0LCo9ZoMZ58KFC7M-jQkMfZ9GtJeXH2r0M_" target="_blank" rel="external">AngularJS 2013 Brad Green</a><br><a href="http://blog.csdn.net/renfufei/article/details/19038123" target="_blank" rel="external">http://blog.csdn.net/renfufei/article/details/19038123</a></p>
</blockquote>
<h2 id="依赖注解-Dependency-Annotation"><a href="#依赖注解-Dependency-Annotation" class="headerlink" title="依赖注解 | Dependency Annotation"></a>依赖注解 | Dependency Annotation</h2><p>injector 怎么知道需要注入何种 service 呢?<br>为了解决依赖关系,应用程序开发者需要提供 injector 需要的 annotation 信息。在 Angular 中,某些API函数通过使用 injector 来调用,请按照API文档。injector 需要知道注入哪些服务给函数。下面是通过 service name 信息对代码进行注解的三种等价方式。他们都是等价的，可以在适当的地方互换使用.<br><a id="more"></a></p>
<h3 id="推断依赖关系-Inferring-Dependencies"><a href="#推断依赖关系-Inferring-Dependencies" class="headerlink" title="推断依赖关系 | Inferring Dependencies"></a>推断依赖关系 | Inferring Dependencies</h3><p>最简单的获取依赖的方式,就是让函数参数名和依赖的名字一致。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyController</span>(<span class="params">$scope, greeter</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给定一个 function, injector 通过检查函数声明和提取参数名称可以推断出 service 的名称 。在上面的例子中, $scope 和 greeter 是需要注入 function 的两个 services。<br>虽然简单直接, 但这种方法在 JavaScript 压缩/混淆 时会失效,因为会重命名方法的参数名。这使得这种注解方式只适用于 <a href="http://www.pretotyping.org/" target="_blank" rel="external">pretotyping</a>, 或者 demo 程序中。</p>
<h3 id="inject-注解-inject-Annotation"><a href="#inject-注解-inject-Annotation" class="headerlink" title="$inject 注解 | $inject Annotation"></a>$inject 注解 | $inject Annotation</h3><p>在产品级的代码中往往会压缩代码，这会重命名方法参数名，AngularJS 便无法判断出原来所需要的服务和变量，为了能够在重命名方法参数名后依然可以注入正确的 services, 函数需要通过 $inject 属性来注解. $inject 属性是一个数组,包含 需要注入的 service 名字。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyController = <span class="function"><span class="keyword">function</span>(<span class="params">renamed$scope, renamedGreeter</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">MyController[<span class="string">'$inject'</span>] = [<span class="string">'$scope'</span>, <span class="string">'greeter'</span>];</span><br></pre></td></tr></table></figure>
<p>在这种情况下,$inject数组中的值的顺序必须和要注入的参数的顺序一致。使用上面的代码片段作为一个例子, <code>$scope</code> 将注入到 <code>renamed$scope</code>, 而 <code>greeter</code> 将注入到 <code>renamedGreeter</code>。再次提醒注意 $inject 注解必须和 函数声明时的实际参数保持同步(顺序,个数…)。<br>对于 controller 声明,这种注解方法是很有用的,因为它将注解信息赋给了 function。</p>
<h3 id="内联注解-Inline-Annotation"><a href="#内联注解-Inline-Annotation" class="headerlink" title="内联注解 | Inline Annotation"></a>内联注解 | Inline Annotation</h3><p>有时候并不方便使用 $inject 注解,比如在注解 directives的时候。比如下面的示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">someModule.factory(<span class="string">'greeter'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">$window</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>因为需要使用临时变量，导致代码膨胀为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> greeterFactory = <span class="function"><span class="keyword">function</span>(<span class="params">renamed$window</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line">greeterFactory.$inject = [<span class="string">'$window'</span>];</span><br><span class="line">someModule.factory(<span class="string">'greeter'</span>, greeterFactory);</span><br></pre></td></tr></table></figure>
<p>这也是提供第三种注解的原因，以数组形式注入：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">someModule.factory(<span class="string">'greeter'</span>, [<span class="string">'$window'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">renamed$window</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;]);</span><br></pre></td></tr></table></figure>
<p><strong>所有的 annotation 风格都是等价的,在 Angular 中,只有支持注入的地方都可以使用.</strong></p>
<h2 id="http-Service-Configuration"><a href="#http-Service-Configuration" class="headerlink" title="$http Service Configuration"></a>$http Service Configuration</h2><p>$http 配置请求模板：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$http(&#123;&#10;    method: string,&#10;    url: string,&#10;    params: object,&#10;    data: string or object,&#10;    headers: object,&#10;    transformRequest: function transform(data, headerGetter) or an array of functions,&#10;    transformResponse: function transform(data, headerGetter) or an array of functions,&#10;    cache: boolean or Cache object,&#10;    timeout: number,&#10;    withCredentials: boolean&#10;&#125;);</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>transformRequest</code> 如果请求的配置对象属性中包含 JS 对象，那么就把这个对象序列化成 JSON 格式。</li>
<li><code>transformResponse</code> 如果检测到了 XSRF(Cross-site Request Forgery) 前缀，则直接丢弃；如果检测到了 JSON 响应，则使用 JSON 解析器对其反序列化。</li>
</ul>
<p>假设有一个服务，需要 POST 数据使用 <code>key1=1&amp;key2=2</code> 来代替 JSON 格式的 <code>{key1: 1, key2: 2}</code>，于是在请求中进行这种转换：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Angular.module(<span class="string">'myApp'</span>)</span><br><span class="line">    .config(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        $httpProvider.defaults.transformRequest = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 使用 jQuery 的 param 方法</span></span><br><span class="line">            <span class="comment">// 把 JSON 数据转换成字符串形式</span></span><br><span class="line">            <span class="keyword">return</span> $.param(data);</span><br><span class="line">        &#125;   </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="使用-RESTful-资源"><a href="#使用-RESTful-资源" class="headerlink" title="使用 RESTful 资源"></a>使用 RESTful 资源</h2><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$resource(<span class="string">'/url/:id'</span>,&#123;id: <span class="string">'@userId'</span>&#125;);</span><br></pre></td></tr></table></figure>
<p><code>@userId</code> 表示如果正在使用一个从服务端返回的对象，当调用这个对象上的任一方法时，对象上的 <code>userId</code> 属性都会被赋给 <code>id</code> 参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CreditCard.get(&#123;id: <span class="number">123</span>&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">card</span>) </span>&#123;</span><br><span class="line">    card.userId = <span class="number">345</span>;</span><br><span class="line">    <span class="comment">// card 对象中的 userId 将赋给 id</span></span><br><span class="line">    card.$save();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="自定义方法"><a href="#自定义方法" class="headerlink" title="自定义方法"></a>自定义方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">myModule.factory(<span class="string">'CreditCard'</span>, [<span class="string">'$resource'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">$resource</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $resource(<span class="string">'/user/:id'</span>, </span><br><span class="line">        &#123;id: <span class="string">'@userId'</span>&#125;,</span><br><span class="line">        &#123;charge: &#123;</span><br><span class="line">            method: <span class="string">'POST'</span>, <span class="comment">// 请求类型</span></span><br><span class="line">            params: &#123;charge: <span class="literal">true</span>&#125;,  <span class="comment">// 传递的参数</span></span><br><span class="line">            isArray: <span class="literal">false</span> <span class="comment">// 返回的结果是否是一个数组</span></span><br><span class="line">        &#125;&#125;);</span><br><span class="line">&#125;]);</span><br></pre></td></tr></table></figure>
<p>这里指定了一个 <code>charge</code> 方法，可以通过一个对象作为 <code>$resource</code> 的第三个参数来配置这个方法，对象中的 key 就是需要暴露的方法名称。</p>
<blockquote>
<p>这是一种灵活的编码风格，根据上面的代码，对于配置对象 <code>{charge: {method: &#39;POST&#39;, params: {charge: true}, isArray: false}}</code>，Angular 会将其解析成一个方法，然后把这个方法绑定到返回的 RESTful 对象上。</p>
</blockquote>
<p>上面的配置对象解释之后的方法为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CreditCard.charge = <span class="function"><span class="keyword">function</span>(<span class="params">charge, isArray</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Callback"><a href="#Callback" class="headerlink" title="Callback"></a>Callback</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> card = CreditCard.query();</span><br></pre></td></tr></table></figure>
<p>上面的 <code>query</code> 调用并没有像 <code>get</code> 一样在回调函数中进行赋值，而是直接将信用卡对象赋值给了 card 变量，你可能会担心在对服务器进行异步请求的情况下，这种代码还能正常运行吗？</p>
<p>这种担心是合理的，但事实上，这段代码完全正确，并且能够运行。这里发生的事情是：Angular 赋给了 card 对象一个（所返回对象或者数组的）引用，只有在未来某个时间对服务器的请求返回来之后，这个引用才被真正的赋值。<strong>在此期间，引用对象一直是空的。</strong></p>
<h2 id="Directive"><a href="#Directive" class="headerlink" title="Directive"></a>Directive</h2><p>从高层面看 Angular 的初始化过程：</p>
<ol>
<li><p><strong>加载脚本</strong><br>加载 Angular 库，并查找 ng-app 指令，从而找到引用边界。</p>
</li>
<li><p><strong>编译阶段</strong><br>在这个阶段中，Angular 将会遍历 DOM 结构，标识出模板中注册的所有指令。对于每一条命令，它会根据指令定义的规则来转换 DOM 结构，如果存在 compile 函数，则调用它。调用 compile 函数将得到一个编译好的 template 函数，它将会调用从指令中搜集而来的 link 函数。</p>
</li>
<li><p><strong>链接阶段</strong><br>为了让视图称为动态的，Angular 会对每条指令运行一个 link 函数。link 函数的一般操作是在 DOM 或者模型上创建监听器，监听器会使视图和模型的内容随时保持同步。</p>
</li>
</ol>
<p>总结来说，后两个阶段就是负责转换模板的编译阶段，以及修改视图中数据的链接阶段。</p>
<h3 id="指令定义选项"><a href="#指令定义选项" class="headerlink" title="指令定义选项"></a>指令定义选项</h3><ul>
<li><code>compile</code> 对模板自身进行转换和编译，此函数在生命周期中只调用一次。如使用 ng-repeat 时，会以编程的方式修改 DOM 模板，生成多个 DOM 元素实例。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">compile: <span class="function"><span class="keyword">function</span> <span class="title">compile</span>(<span class="params">tElement, tAttrs, transclude</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  &#123;</span><br><span class="line">        pre: <span class="function"><span class="keyword">function</span> <span class="title">preLink</span>(<span class="params">scope, iElement, iAttrs, controller</span>) </span>&#123;...&#125;, <span class="comment">// 运行于编译阶段之后，指令链接到子元素之前</span></span><br><span class="line">        post: <span class="function"><span class="keyword">function</span> <span class="title">postLink</span>(<span class="params">scope, iElement, iAttrs, controller</span>) </span>&#123;...&#125;, <span class="comment">// 运行于所有子元素指令都链接之后</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>link</code> 负责在模型和视图之间进行动态关联。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">preLink</span>(<span class="params">scope, iElement, iAttrs, controller</span>) </span>&#123;...&#125;,</span><br></pre></td></tr></table></figure>
<p>作用域在链接阶段才会被绑定到编译之后的 link 函数上，然后再通过数据绑定技术，指令就变成了动态的。如果要修改 DOM 结构必须在 <code>postLink</code> 函数中来执行，如果在 <code>preLink</code> 中执行，则会破坏数据绑定过程，导致链接出错。</p>
<div class="tip"><br><div><strong>compile 函数和 link 函数不同点</strong></div><br><div>1. link 函数会访问 scope 对象，而 compile 不会。这是因为，scope 对象在编译阶段还不存在。</div><br><div>2. compile 函数会接收模板元素及其属性列表，而 link 函数会接收到视图实例对象（视图实例由模板创建）。</div><br></div>
</div></article></div></section><footer><div class="paginator"><a href="/2016/01/21/angularjs-api-factory-service-provider/" class="prev">PREV</a><a href="/2016/01/01/github-gitcafe-domain-binding-principle/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2017 <a href="http://leone.wang">LeoneWang</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>