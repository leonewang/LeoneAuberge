<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Think About JavaScript『this Pointer』 · Leone Auberge</title><meta name="description" content="Think About JavaScript『this Pointer』 - LeoneWang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/share" target="_self" class="nav-list-link">SHARE</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li><li class="nav-list-item"><a href="https://github.com/leonewang" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Think About JavaScript『this Pointer』</h1><div class="post-info">Oct 23, 2015</div><div class="post-content"><p>说到<code>this</code>，就不得不提到<code>function</code>，<strong>正是由于调用function的对象不同，才导致了this的指向不同</strong>。所以以前老是去记忆每种调用function的情况所对应的this，因为情况有限而且很少，所以这当然是可行的——对于聪明人来说，所以我不得不思考另外一些方式来让我记住。</p>
<div class="tip">那么首先我们需要明确的一个事情是：<strong>function也是对象</strong>。同时我们还需要明确的一个事情是：<strong>function执行时是在某个特定的上下文中执行的</strong>。<a id="more"></a></div>

<p>那什么是上下文呢？打个比方，比如你练会了辟邪剑谱，那这时候你的掌门让你用辟邪剑谱砍人。如果仅仅是这样的话，你是没法完成这个任务的，因为你必须得知道要砍谁吧，其次去哪儿砍吧，那么是个地下通道还是一望无尽的大草原，要是地下通道你走路都困难，还怎么用辟邪剑谱呢对吧。这就是上下文，函数执行时它也需要一些额外的信息来支撑它的运行。</p>
<p>那么既然function是对象的话，就会有方法。而function中最核心的方法是 <code>call</code> 方法。因此我们就从这儿入手。</p>
<h2 id="call方法"><a href="#call方法" class="headerlink" title="call方法"></a>call方法</h2><p>先来看一下如何使用call方法:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">content</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"From "</span> + <span class="keyword">this</span> + <span class="string">": Hello "</span>+ content);</span><br><span class="line">&#125;</span><br><span class="line">say.call(<span class="string">"Bob"</span>, <span class="string">"World"</span>); <span class="comment">//==&gt; From Bob: Hello World</span></span><br></pre></td></tr></table></figure>
<p>接下来仔细分析一下call的用法：<br><strong>Step1:</strong> 把第二个到最后一个参数作为函数执行时要传入的参数<br><strong>Step2:</strong> 把函数执行时的this指向第一个参数<br><strong>Step3:</strong> 在上面这个特殊的上下文中执行函数</p>
<p>上面例子中，我们通过call方法，让say函数执行时的<code>this</code>指向”Bob”，然后把”World”作为参数传进去，所以输出结果是可以预见的。</p>
<p>js执行函数时会默认完成以上的步骤，你可以把直接调用函数理解为一种语法糖<br>比如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">word</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(world);</span><br><span class="line">&#125;</span><br><span class="line">say(<span class="string">"Hello world"</span>);</span><br><span class="line">say.call(<span class="built_in">window</span>, <span class="string">"Hello world"</span>);</span><br></pre></td></tr></table></figure>
<p>以上可以把<code>say(&quot;Hello world&quot;)</code>看做是<code>say.call(window,&quot;Hello world&quot;)</code>的语法糖。</p>
<p>这个结论非常关键。所以以后每次看见<code>functionName(xxx)</code>的时候，你需要马上在脑海中把它替换为<code>functionName.call(window,xxxx)</code>，这对你理解this的指向非常重要。不过也有例外，<strong>在ES5的strict mode中call的第一个参数不是window而是undefined</strong>。之后的例子我假设总是不在strictmode下，但你需要记住strictmode有一点儿不同。</p>
<p>对于匿名函数来说，上面的结论也是成立的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;)(<span class="string">"aa"</span>);</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;    </span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">&#125;).call(<span class="built_in">window</span>, <span class="string">"aa"</span>);</span><br></pre></td></tr></table></figure>
<p>函数作为对象的方法被调用，直接来看代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name : <span class="string">"caibirdme"</span>,</span><br><span class="line">    run : <span class="function"><span class="keyword">function</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">"has been running for over "</span>+ time+ <span class="string">" minutes"</span>);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">person.run(<span class="number">30</span>);</span><br><span class="line"><span class="comment">//==&gt; caibirdme has been running for over 30 minutes//等价于</span></span><br><span class="line">person.run.call(person, <span class="number">30</span>); <span class="comment">// the same</span></span><br></pre></td></tr></table></figure>
<p>你会发现这里call的第一个参数是person而不是window。当你明白了这两点，下意识地把函数调用翻译成<code>foo.call()</code>的形式，明确call的第一个参数，那基本上this的问题就难不住你了。</p>
<p>还是来举几个例子。<br>例一：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">thing</span>) </span>&#123;  </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span> + <span class="string">" says hello "</span> + thing);</span><br><span class="line">&#125;</span><br><span class="line">  person = &#123; name: <span class="string">"caibirdme"</span> &#125;  </span><br><span class="line">  person.hello = hello;</span><br><span class="line">  person.hello(<span class="string">"world"</span>)</span><br><span class="line"><span class="comment">// 相当于执行 person.hello.call(person, "world")</span></span><br><span class="line">hello(<span class="string">"world"</span>)</span><br><span class="line"><span class="comment">// 相当于执行 hello.call(window, "world")</span></span><br></pre></td></tr></table></figure>
<p>例二：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    x: <span class="number">20</span>,</span><br><span class="line">    f: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>.x); &#125;</span><br><span class="line">&#125;;</span><br><span class="line">    obj.f(); <span class="comment">// obj.f.call(obj)//==&gt; 20</span></span><br><span class="line">obj.innerobj = &#123;</span><br><span class="line">    x: <span class="number">30</span>,</span><br><span class="line">    f: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>.x); &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.innerobj.f();</span><br><span class="line"><span class="comment">// obj.innerobj.f.call(obj.innerobj)// ==&gt; 30</span></span><br></pre></td></tr></table></figure>
<p>例三：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    x: <span class="number">20</span>,</span><br><span class="line">    f: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.x); <span class="comment">//this equals obj</span></span><br><span class="line">                <span class="comment">// ==&gt; 20</span></span><br><span class="line">        <span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>.x); &#125;</span><br><span class="line">        foo();</span><br><span class="line">        <span class="comment">// foo.call(window)</span></span><br><span class="line">        <span class="comment">//foo中this被指定为window，所以==&gt; 10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.f();  <span class="comment">// obj.f.call(obj)// ==&gt; 20 10</span></span><br></pre></td></tr></table></figure>
<p>由例三引出一个非常common的问题，如果我想让foo输出20怎么办？这时候需要用到一点小技巧。</p>
<p>例四：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    x: <span class="number">20</span>,</span><br><span class="line">    f: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line"><span class="comment">//使用that保留当前函数执行上下文的this</span></span><br><span class="line">        <span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(that.x); &#125;</span><br><span class="line"><span class="comment">//此时foo函数中的this仍然指向window，但我们使用that取得obj</span></span><br><span class="line">        foo(); <span class="comment">// foo.call(window)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.f();</span><br><span class="line">obj.f.call(obj)<span class="comment">// ==&gt; 20 20</span></span><br></pre></td></tr></table></figure>
<p>再来一个稍微难一点点的(但其实用call替换法一点儿也不难)。</p>
<p>例五：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    x: <span class="number">20</span>,</span><br><span class="line">    f: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>.x); &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.f(); <span class="comment">// obj.f.call(obj)// ==&gt; 20</span></span><br><span class="line"><span class="keyword">var</span> fOut = obj.f;</span><br><span class="line">fOut();</span><br><span class="line"><span class="comment">// fOut.call(window)//==&gt; 10</span></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    x: <span class="number">30</span>,</span><br><span class="line">    f: obj.f</span><br><span class="line">&#125;</span><br><span class="line">obj2.f(); <span class="comment">// obj2.f.call(obj2)//==&gt; 30</span></span><br></pre></td></tr></table></figure>
<p>例五有些同学会可能出错的原因，是没有明确我上面说的：<strong>this是在执行是才会被确认的</strong>。他可能会认为说<code>obj.f</code>那个函数定义在obj里面，那this就该指向obj。如果看完这篇文章你还这么想的话，我会觉得我的表达水平太失败了……</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>先看一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func person(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> caibirdme = <span class="keyword">new</span> person(<span class="string">"deen"</span>);</span><br><span class="line"><span class="comment">// caibirdme.name == deen</span></span><br></pre></td></tr></table></figure>
<p>我上面也说了，函数在用作构造函数时同样可以用call方法去代替，那这里怎么代替呢？<br>这里你又需要明确一点：<code>new constrcut()是一种创建对象的语法糖</code>，它等价于</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> person(<span class="string">"deen"</span>);</span><br><span class="line"><span class="comment">//通过new创建了一个对象</span></span><br><span class="line"><span class="comment">//new是一种语法糖，new person等价于</span></span><br><span class="line"><span class="keyword">var</span> bar = (<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _newObj = &#123;</span><br><span class="line">        constructor : person,</span><br><span class="line">        __proto__ : person.prototype,</span><br><span class="line">    &#125;;</span><br><span class="line">    _newObj.constructor(name);</span><br><span class="line">    <span class="comment">// _newObj.constructor.call(_newObj, name)</span></span><br><span class="line">    <span class="keyword">return</span> _newObj;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>So you can see……为什么new的时候this就指向新的对象了吧？</p>
<p>通过我这篇文章，我希望学会通过把一个函数调用替换成<code>funcName.call</code>的形式，从而理解运行时上下文中this到底指向谁。总结来说就是下面两个等价变形：</p>
<p><strong>foo() —&gt; foo.call(window)</strong><br><strong>obj.foo() –&gt; obj.foo.call(obj)</strong></p>
<p>只要理解以上两个变形，this就不再是问题啦！！希望我的这种方法对各位同学认识this有所帮助，不要再像我曾经一样掉入this的坑中。</p>
<p>总之：<code>this</code> 当前执行环境的上下文，<code>call</code> 和 <code>apply</code> 修改对象的上下文。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2015/11/09/q-jsp-loaded-incomplete/" class="prev">PREV</a><a href="/2015/09/23/http-getpost-max-length/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2016 <a href="http://leonewang.wang">LeoneWang</a>, unless otherwise noted.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-73794445-1",'auto');ga('send','pageview');</script></body></html>