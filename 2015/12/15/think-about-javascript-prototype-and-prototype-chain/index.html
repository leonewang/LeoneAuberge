<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Think about JavaScript『prototype and prototype chain』 · Leone Auberge</title><meta name="description" content="普通对象与函数对象JavaScript 中，万物皆对象！但对象也是有区别的。分为普通对象和函数对象，Object ，Function 是JS自带的函数对象。下面举例说明。
12345678&lt;span class=&quot;"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">博客</a></li><li class="nav-list-item"><a href="/share" target="_self" class="nav-list-link">分享</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li><li class="nav-list-item"><a href="https://github.com/leonewang" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Think about JavaScript『prototype and prototype chain』</h1><div class="post-meta"><div class="post-time">2015年12月15日</div></div><div class="post-content"><h2 id="u666E_u901A_u5BF9_u8C61_u4E0E_u51FD_u6570_u5BF9_u8C61"><a href="#u666E_u901A_u5BF9_u8C61_u4E0E_u51FD_u6570_u5BF9_u8C61" class="headerlink" title="普通对象与函数对象"></a>普通对象与函数对象</h2><p>JavaScript 中，万物皆对象！但对象也是有区别的。分为普通对象和函数对象，Object ，Function 是JS自带的函数对象。下面举例说明。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"> <span class="keyword">var</span> f2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"> <span class="keyword">var</span> f3 = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'str'</span>,<span class="string">'console.log(str)'</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> o1 = &#123;&#125;;</span><br><span class="line"> <span class="keyword">var</span> o2 =<span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"> <span class="keyword">var</span> o3 = <span class="keyword">new</span> f1();</span><br><span class="line"></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Object</span>); <span class="comment">//function</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>); <span class="comment">//function</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">typeof</span> o1); <span class="comment">//object</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">typeof</span> o2); <span class="comment">//object</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">typeof</span> o3); <span class="comment">//object</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">typeof</span> f1); <span class="comment">//function</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">typeof</span> f2); <span class="comment">//function</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">typeof</span> f3); <span class="comment">//function</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>  在上面的例子中 <code>o1 o2 o3</code> 为普通对象，<code>f1 f2 f3</code> 为函数对象。怎么区分，其实很简单，<strong>凡是通过 <code>new Function()</code> 创建的对象都是函数对象</strong>，其他的都是普通对象。f1,f2,归根结底都是通过 <code>new Function()</code>的方式进行创建的。<strong>Function Object 也都是通过<code>New Function()</code>创建的</strong>。</p>
<h2 id="u539F_u578B_u5BF9_u8C61"><a href="#u539F_u578B_u5BF9_u8C61" class="headerlink" title="原型对象"></a>原型对象</h2><p> 在JavaScript 中，每当定义一个对象（函数）时候，对象中都会包含一些预定义的属性。其中函数对象的一个属性就是原型对象<code>prototype</code>。注：普通对象没有prototype,但有<code>__proto__</code>属性。</p>
<p>  原型对象其实就是普通对象（<strong>Function.prototype除外,它是函数对象，但它很特殊，他没有prototype属性（前面说道函数对象都有prototype属性）</strong>）。看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"> <span class="built_in">console</span>.log(f1.prototype) <span class="comment">//f1&#123;&#125;</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">typeof</span> f1. prototype) <span class="comment">//Object</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>.prototype) <span class="comment">// Function，这个特殊</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Object</span>.prototype) <span class="comment">// Object</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>.prototype.prototype) <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<p> 从这句<code>console.log(f1.prototype) //f1 {}</code> 的输出就结果可以看出，<code>f1.prototype</code>就是f1的一个实例对象。<strong>就是在f1创建的时候,创建了一个它的实例对象并赋值给它的prototype</strong>，基本过程如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> temp = <span class="keyword">new</span> f1();</span><br><span class="line">f1. prototype = temp;</span><br></pre></td></tr></table></figure>
<p>  所以，<code>Function.prototype</code>为什么是函数对象就迎刃而解了，上文提到凡是new Function ()产生的对象都是函数对象，所以temp1是函数对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> temp1 = <span class="keyword">new</span> <span class="built_in">Function</span> ();</span><br><span class="line"><span class="built_in">Function</span>.prototype = temp1;</span><br></pre></td></tr></table></figure>
<p>上篇 <a href="http://leonewang.wang/2015/10/23/think-about-javascript-this-pointer/"> <em>this 指针理解</em> </a> 中提到：如果在一个函数前面带上<code>new</code>关键字来调用，那么JavaScript会给这个函数添加一个<code>prototype</code>属性，并创建一个新对象，同时在调用这个函数时将<code>this</code>指针绑定到这个对象上，那么为什么<code>this</code>指针会绑定到新对象？</p>
<p>这里你又需要明确一点：<code>new constrcut()</code>是一种创建对象的语法糖，它等价于：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> person(<span class="string">"deen"</span>);</span><br><span class="line"><span class="comment">//通过new创建了一个对象</span></span><br><span class="line"><span class="comment">//new是一种语法糖，new person等价于</span></span><br><span class="line"><span class="keyword">var</span> bar = (<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _newObj = &#123;</span><br><span class="line">       constructor : person,</span><br><span class="line">       __proto__ : person.prototype,</span><br><span class="line">   &#125;;</span><br><span class="line">   _newObj.constructor(name);</span><br><span class="line">   <span class="comment">// _newObj.constructor.call(_newObj, name)</span></span><br><span class="line">   <span class="keyword">return</span> _newObj;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>那原型对象是用来做什么的呢？主要作用是用于<strong>继承</strong>。举了例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line"> &#125;;</span><br><span class="line"> person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">var</span> zjh = <span class="keyword">new</span> person(<span class="string">'zjh'</span>);</span><br><span class="line"> zjh.getName(); <span class="comment">//zjh</span></span><br></pre></td></tr></table></figure>
<p>从这个例子可以看出，通过给<code>person.prototype</code>设置了一个函数对象的属性，那样person实例（例中：zjh）出来的普通对象就继承了这个属性。具体是怎么实现的继承，就要讲到下面的原型链了。</p>
<h2 id="u539F_u578B_u94FE"><a href="#u539F_u578B_u94FE" class="headerlink" title="原型链"></a>原型链</h2><p>JS在创建对象（不论是普通对象还是函数对象）的时候，都有一个叫做<code>__proto__</code>的内置属性，<strong>用于指向创建它的函数对象的原型对象prototype</strong>。以上面的例子为例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(zjh.__proto__ === person.prototype) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>同样，person.prototype对象也有<code>__proto__</code>属性，它指向创建它的函数对象（Object）的prototype</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person.prototype.__proto__ === <span class="built_in">Object</span>.prototype) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>继续，Object.prototype对象也有<code>__proto__</code>属性，但它比较特殊，为null</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__) <span class="comment">//null</span></span><br></pre></td></tr></table></figure>
<p>我们把这个<strong>有<code>__proto__</code>串起来的直到<code>Object.prototype.__proto__</code>为null的链叫做原型链</strong>。如下图：</p>
<p><img src="http://7xpp7u.com1.z0.glb.clouddn.com/prototype-1.jpg" alt="prototype-1"></p>
<h2 id="u5185_u5B58_u7ED3_u6784_u56FE"><a href="#u5185_u5B58_u7ED3_u6784_u56FE" class="headerlink" title="内存结构图"></a>内存结构图</h2><p>为了更加深入和直观的进行理解，下面我们画一下上面的<strong>内存结构图</strong>：</p>
<p><img src="http://7xpp7u.com1.z0.glb.clouddn.com/prototype-2.jpg" alt="prototype-2"></p>
<p><strong>画图约定</strong>：</p>
<p><img src="http://7xpp7u.com1.z0.glb.clouddn.com/prototype-3.jpg" alt="prototype-3"></p>
<p><strong>疑点解释</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>Object是函数对象，是通过new Function()创建，所以<code>Object.__proto__</code>指向<code>Function.prototype</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>Function 也是对象函数，也是通过new Function()创建，所以<code>Function.__proto__</code>指向<code>Function.prototype</code>。</p>
<blockquote>
<p>自己是由自己创建的，好像不符合逻辑，但仔细想想，现实世界也有些类似，你是怎么来的，你妈生的，你妈怎么来的，你姥姥生的，……类人猿进化来的，那类人猿从哪来，一直追溯下去……，就是无，（NULL生万物）。正如《道德经》里所说“无，名天地之始”。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>其实这一点我也有点困惑，不过也可以试着解释一下。<br><strong>Function.prototype</strong> 是个函数对象，理论上他的<code>__proto__</code>应该指向 <code>Function.prototype</code>，就是他自己，自己指向自己，没有意义。<br>JS一直强调万物皆对象，函数对象也是对象，给他认个祖宗，指向<code>Object.prototype。Object.prototype.__proto__ === null</code>，保证原型链能够正常结束。</p>
<h2 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h2><p>原型对象prototype中都有个预定义的<strong>constructor</strong>属性，用来引用它的函数对象。这是一种循环引用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">person.prototype.constructor === person <span class="comment">//true</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.constructor === <span class="built_in">Function</span> <span class="comment">//true</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.constructor === <span class="built_in">Object</span> <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>完善下上面的内存结构图：</p>
<p><img src="http://7xpp7u.com1.z0.glb.clouddn.com/prototype-4.jpg" alt="prototype-4"></p>
<p>有两点需要注意：</p>
<ol>
<li>注意<code>Object.constructor===Function；//true</code> <strong>本身Object就是Function函数构造出来的</strong></li>
<li>如何<strong>查找</strong>一个对象的constructor，就是在该对象的原型链上<strong>寻找碰到的第一个constructor属性所指向的对象</strong></li>
</ol>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><ol>
<li>原型和原型链是JS实现继承的一种模型。</li>
<li>原型链的形成是真正是靠<strong><strong>proto</strong> 而非prototype</strong></li>
</ol>
<p>要深入理解这句话，我们再举个例子，看看前面你真的理解了吗？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> animal = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> dog = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  animal.price = <span class="number">2000</span>;</span><br><span class="line">  dog.prototype = animal;</span><br><span class="line">  <span class="keyword">var</span> tidy = <span class="keyword">new</span> dog();</span><br><span class="line">  <span class="comment">// tiny.__proto__ 指向 dog.prototype</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(dog.price) <span class="comment">//undefined</span></span><br><span class="line">  <span class="built_in">console</span>.log(tidy.price) <span class="comment">// 2000</span></span><br></pre></td></tr></table></figure>
<p>为什么呢？画一下内存图：</p>
<p><img src="http://7xpp7u.com1.z0.glb.clouddn.com/prototype-5.jpg" alt="prototype-5"></p>
<p>这说明什么问题呢，执行dog.price的时候，发现没有price这个属性，<strong>虽然prototype指向的animal有这个属性，但它并没有去沿着这个“链”去寻找</strong>。同样，执行tidy.price的时候，也没有这个属性，但是<code>__proto__</code>指向了animal，它会沿着这个链去寻找，animal中有price属性，所以tidy.price输出2000。由此得出，原型链的真正形成是靠的<strong><strong>proro</strong></strong>，而不是prototype。<br>因此，如果在这样指定<code>dog.__proto__ = animal</code>。那<code>dog.price = 2000</code>。</p>
<p>最后打个比喻，虽然不是很确切，但可能对原型的理解有些帮助。</p>
<p><img src="http://7xpp7u.com1.z0.glb.clouddn.com/prototype-6.jpg" alt="prototype-6"></p>
<p>父亲（函数对象），先生了一个大儿子（<strong>prototype</strong>），也就是你大哥，父亲给你大哥买了好多的玩具，当你出生的时候，你们之间的亲情纽带（<strong><strong>proto</strong></strong>）会让你自然而然的拥有了你大哥的玩具。同样，你也先生个大儿子，又给他买了好多的玩具，当你再生儿子的时候，你的小儿子会自然拥有你大儿子的所有玩具。至于他们会不会打架，这不是我们的事了。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2015/12/22/angularjs-resource-interface-with-restful-api/" class="prev">上一篇</a><a href="/2015/11/09/q-jsp-loaded-incomplete/" class="next">下一篇</a></div></footer><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?ed77053554825c09d2021287e3a25e51";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>