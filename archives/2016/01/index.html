<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Leone Auberge</title><meta name="description" content="LeoneWang's blog"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">博客</a></li><li class="nav-list-item"><a href="/share" target="_self" class="nav-list-link">分享</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li><li class="nav-list-item"><a href="https://github.com/leonewang" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><section class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/01/18/angularjs-notes/" class="post-title-link">AngularJS Notes</a></h2><div class="post-meta"><div class="post-time">2016年1月18日</div></div><div class="post-content"><blockquote>
<p>REF:<br><a href="http://baike.baidu.com/link?url=SlAzoxj6IVBVqvcoKI6EExxuU1a4yXzW9CiSMFdN9azJXxovxoD0LCo9ZoMZ58KFC7M-jQkMfZ9GtJeXH2r0M_">AngularJS 2013 Brad Green</a><br><a href="http://blog.csdn.net/renfufei/article/details/19038123">http://blog.csdn.net/renfufei/article/details/19038123</a></p>
</blockquote>
<h2 id="u4F9D_u8D56_u6CE8_u89E3__7C_Dependency_Annotation"><a href="#u4F9D_u8D56_u6CE8_u89E3__7C_Dependency_Annotation" class="headerlink" title="依赖注解 | Dependency Annotation"></a>依赖注解 | Dependency Annotation</h2><p>injector 怎么知道需要注入何种 service 呢?<br>为了解决依赖关系,应用程序开发者需要提供 injector 需要的 annotation 信息。在 Angular 中,某些API函数通过使用 injector 来调用,请按照API文档。injector 需要知道注入哪些服务给函数。下面是通过 service name 信息对代码进行注解的三种等价方式。他们都是等价的，可以在适当的地方互换使用.<br></div><a href="/2016/01/18/angularjs-notes/" class="read-more">... more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/01/01/github-gitcafe-domain-binding-principle/" class="post-title-link">GitHub/GitCafe Domain Binding Principle</a></h2><div class="post-meta"><div class="post-time">2016年1月1日</div></div><div class="post-content"><p>根据<a href="https://www.zhihu.com/question/26609475">Rainux Luo, CTO@GitCafe</a>在知乎的描述和自己的理解做出描述：</p>
<ol>
<li>GitHub/GitCafe 会为每个包含 gh-pages/gitcafe-pages 分支的项目创建包含该分支内容的、符合特定命名规则的目录 wwwroot。</li>
<li>GitHub/GitCafe 虚拟了一个服务器，它被配置成使用 Name-based Virtual Server  方式来发布该分支下的目录内容，这个被虚拟服务器的域名就是 <code>{username}.gitxxx.io</code> 或者是用户绑定的域名，那么自然可以访问静态页面。</li>
<li><p>那么域名是如何绑定到这个虚拟服务器上的呢？首先要知道 <code>A</code> 和 <code>CNAME</code> 记录的概念。</p></div><a href="/2016/01/01/github-gitcafe-domain-binding-principle/" class="read-more">... more</a></article></li></ul></section><footer><div class="paginator"><a class="prev"> </a><a class="prev"> </a></div></footer><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?ed77053554825c09d2021287e3a25e51";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>